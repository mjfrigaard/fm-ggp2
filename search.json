[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggplot2: field manual",
    "section": "",
    "text": "Welcome!\nWelcome to the ggplot2 field manual! This resource was created to serve as a bookmark/quick reference for building graphs with ggplot2."
  },
  {
    "objectID": "index.html#intent",
    "href": "index.html#intent",
    "title": "ggplot2: field manual",
    "section": "Intent",
    "text": "Intent\nThis manual was written to help answer questions like,\n\n“What graph should I use?”\n“Can I build this graph (given the data I have)?”\nWhat was the name of that visualization I saw on #TidyTuesday?"
  },
  {
    "objectID": "index.html#get-started",
    "href": "index.html#get-started",
    "title": "ggplot2: field manual",
    "section": "Get started",
    "text": "Get started\nIn order to maximize reproducibility, this manual only relies on a few packages:\n\nInstall ggplot2 (option 1)\nInstall ggplot2 and the data packages using the code below:\n\n\n\n\n\n\n\n\n\nCode\ndata_pkgs &lt;- c(\"palmerpenguins\", \"fivethirtyeight\", \"ggplot2movies\", \"babynames\")\ninstall.packages(data_pkgs)\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nlibrary(fivethirtyeight)\nlibrary(ggplot2movies)\nlibrary(babynames)\n\n\n\n\nInstall tidyverse (option 2)\nggplot2 is part of the tidyverse, but you can also install this package separately.\n\n\n\n\n\n\n\n\n\nCode\ndata_pkgs &lt;- c(\"palmerpenguins\", \"fivethirtyeight\", \"ggplot2movies\", \"babynames\")\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\nlibrary(palmerpenguins)\nlibrary(fivethirtyeight)\nlibrary(ggplot2movies)\nlibrary(babynames)"
  },
  {
    "objectID": "index.html#graph-categories",
    "href": "index.html#graph-categories",
    "title": "ggplot2: field manual",
    "section": "Graph Categories",
    "text": "Graph Categories\nGraphs have been categorized into the following types (you can see them in the floating table of contents to your left).\n\nUnivariate: if you have a single column you’re trying to visualize\nAmounts: counts or simple summary statistics of one or two columns in a dataset\nProportions: ratio displays of part-to-whole\nDistributions: displaying the shape of a variable’s values (normalcy, skewness, kurtosis, etc.)\nDates & Times: changes in quantitative or categorical variables over a dimension of time (date-time, date, year, month, quarter, etc.).\nRelationships: how does the change of values in variable x affect the values in variable y (and possibly z)?\n\nSome graphs can justifiably belong to more than one category, and wherever this is the case, I’ve tried to include links to other applications in the notes."
  },
  {
    "objectID": "index.html#the-data",
    "href": "index.html#the-data",
    "title": "ggplot2: field manual",
    "section": "The Data",
    "text": "The Data\nThe data packages used in this manual are available to preview below.\n\npalmerpenguins::penguins\nThe majority of the graphs in the manual are built using the palmerpenguins::penguins data.\n\n\n\n…so…many…PENGUINS!\n\n\n\n\nArtwork by allison_horst\n\n\n\n\n\n\n\n\nExpand to view the data in palmerpenguins::penguins\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nSource: https://github.com/allisonhorst/palmerpenguins/\n\n\nfivethirtyeight\nUse the table below to view the datasets in this package.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpand to view the data in the fivethirtyeight package\n\n\n\n\n\n\nTo view a table of available datasets in the fivethirtyeight package, view the Data Frame Name and Article Title columns in the datasets_master table\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nSource: https://github.com/fivethirtyeight/data\n\n\nggplot2movies::movies\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpand to view a sample of the data in ggplot2movies::movies\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nSource: https://www.imdb.com/\n\n\nbabynames::babynames\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpand to view a sample of the data in babynames::babynames\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nSource: http://www.ssa.gov/oact/babynames/limits.html\nWhy not manually create the graph datasets with data.frame() or tibble()/tribble()?\nIn my opinion, using manually generated data is great for reproducible examples, but they rarely look like data ‘caught in the wild.’ The data packages above are also well maintained and can be used to provide a variety of examples."
  },
  {
    "objectID": "index.html#assumptions",
    "href": "index.html#assumptions",
    "title": "ggplot2: field manual",
    "section": "Assumptions",
    "text": "Assumptions\nThe code and examples assume the reader has already answered the question, “what kind of data do I have?”\nIf not, I highly recommend the skimr and inspectdf packages for getting to know your data better.\nAnother question to consider–but not covered in this manual–is, “who will the audience be for this graph?”\nGreat resources for this include Communicating with Data: The Art of Writing for Data Science by Deborah Nolan and Sara Stoudt and Truthful Art, The: Data, Charts, and Maps for Communication, by Alberto Cairo."
  },
  {
    "objectID": "index.html#who-was-this-written-for",
    "href": "index.html#who-was-this-written-for",
    "title": "ggplot2: field manual",
    "section": "Who was this written for?",
    "text": "Who was this written for?\nI created this resource with the following learner personas in mind:\n\nGarth is a data analyst putting together a slide deck for an upcoming meeting. He had a few statistics courses with R in college, and has picked up additional experience and skills from the different positions he’s held and various online tutorials. He’s currently building the graphs in his slides with ggplot2, but had grown tired of them and would like to customize his presentation to make it more engaging.\nMatilda is a data journalist hoping to add a few graphs to a piece she has been working on. She has 10 years of experience working with WordPress, writes and publishes on her own blog, and has an intermediate understanding of HTML & CSS. However, she has only been programming in R for about 6 months.\nIgor is a researcher who has been working in academia for 15 years. He’s comfortable writing R code, knows the kinds of graphs he’d like to build, but he only knows how to build these using the base R graphics. He’d like to learn how to duplicate the graphs he’s already created in base R using ggplot2.\n\n\nWhat’s been left out?\nBecause this is intended to be a field manual (and not a textbook), I’ve omitted most of the underlying principles and structure of the ggplot2 syntax.\n\n\nWhere can I find what’s been left out?\nIf you’re looking for a comprehensive resource on ggplot2, I recommend the excellent free text, the ggplot2 website, and Data Visualization: a practical guide by Kieran Healy.\nIf you know the graph you’d like to build, and you’re just looking for the code or package(s) to build it, I’d check out the R graph gallery or R graphics cookbook."
  },
  {
    "objectID": "index.html#code-style-structure",
    "href": "index.html#code-style-structure",
    "title": "ggplot2: field manual",
    "section": "Code style & structure",
    "text": "Code style & structure\nThe field manual follows a Rule of Least Power Principle, in the sense that “a language with a straightforward syntax may be easier to analyze than an otherwise equivalent one with more complex structure.”\nIn other words, assuming the reader has some understanding of R and the tidyverse, the code for each graph is meant to be read and understood without having to run it.\nEach graph has, at minimum, the following sections and tabs:\n\nGraph info\n\nShould I use this graph?\n\nThis graph requires:\n\n\nDescription\n\nSet up\n\nPackages and Data\n\nCode for installing development version of packages (if necessary) for graphs and data\n\nAny steps used to create (i.e., manipulate and prepare) the data for the graph\n\n\n\nThe grammar\n\nCode to build the labels and graph layers\n\nGraph labels have the labs_ prefix\n\nGraph layers have a ggp2_ prefix\n\n\n\nMore info\n\nAdditional methods, arguments, or applications\n\nColor palettes\n\nComplimentary packages\n\n\n\nCode Style:\nI’ve attempted to balance brevity and clarity, but with the assumption that its best to err on the latter. I’ve also followed the general principle that if a graph can be easily built using one of ggplot2 ’s geom_* functions, that method is shown first."
  },
  {
    "objectID": "index.html#theme",
    "href": "index.html#theme",
    "title": "ggplot2: field manual",
    "section": "Theme",
    "text": "Theme\nThe theme used in the graphs is custom and uses combined elements from ggplot2::theme_minimal() and ggplot2::theme_void(). View it here."
  },
  {
    "objectID": "univariate.html",
    "href": "univariate.html",
    "title": "UNIVARIATE",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nUnivariate graphs: These graphs are useful if you have a single column you’re trying to visualize.\n\nBar graphs\nHistograms\nFrequency polygons\nDot-plots\nDensity plots\nViolin plots\nBox-plots"
  },
  {
    "objectID": "bar_graphs.html#description",
    "href": "bar_graphs.html#description",
    "title": "1  Bar graphs",
    "section": "1.1 Description",
    "text": "1.1 Description\nA bar graph (or bar chart) is typically used to display counts for the discrete levels of a categorical variable, like political affiliation, hair color, or race/ethnicity (or species of penguin!).\nBar graphs can be arranged vertically or horizontally, but the length of the bar represents the ‘count’ for each category value.\nIn ggplot2, bar graphs can be built using geom_bar() (see also: geom_col())."
  },
  {
    "objectID": "bar_graphs.html#set-up",
    "href": "bar_graphs.html#set-up",
    "title": "1  Bar graphs",
    "section": "1.2 Set up",
    "text": "1.2 Set up\n\nPACKAGES:\n\n\nInstall packages.\n\n\n\n\nCode\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins) \nlibrary(ggplot2)\n\n\n\n\nDATA:\n\n\n\n\n\n\nArtwork by Allison Horst\n\n\n\nFilter the missing values from species in the palmerpenguins::penguins data and store it in penguins_bar.\n\n\n\n\nCode\npenguins_bar &lt;- palmerpenguins::penguins |&gt; \n    dplyr::filter(!is.na(species))\nglimpse(penguins_bar)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, …\n#&gt; $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen,…\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3…\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6…\n#&gt; $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181…\n#&gt; $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650…\n#&gt; $ sex               &lt;fct&gt; male, female, female, NA, female…\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 20…"
  },
  {
    "objectID": "bar_graphs.html#grammar",
    "href": "bar_graphs.html#grammar",
    "title": "1  Bar graphs",
    "section": "1.3 Grammar",
    "text": "1.3 Grammar\n\nCODE:\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nMap species to the x axis\nMap species to the fill aesthetic inside the aes() of geom_bar()\nRemove the legend with show.legend = FALSE\n\n\n\n\nCode\nlabs_bar &lt;- labs(\n  title = \"Adult foraging penguins\",\n  subtitle = \"Distribution of flipper length\",\n  x = \"Species\", y = \"Count\", \n  fill = \"Species\")\nggp2_bar &lt;- ggplot(data = penguins_bar,\n       aes(x = species)) +\n    geom_bar(aes(fill = species), \n        show.legend = FALSE)\nggp2_bar +\n  labs_bar\n\n\n\n\nGRAPH:"
  },
  {
    "objectID": "bar_graphs.html#more-info",
    "href": "bar_graphs.html#more-info",
    "title": "1  Bar graphs",
    "section": "1.4 More info",
    "text": "1.4 More info\n\nThe connection between statistical transformations and geoms is an important principle for building graphs (and mastering the grammar) with ggplot2\n\nBelow we cover why geom_bar(stat = \"count\") produces the same result as stat_count(geom = \"bar\")\n\n\n\n\n“every geom has a default stat, and every stat a default geom.” - ggplot2 book\n\nBar graphs can also be created with geom_col()\n\n\n1.4.1 stats and geoms\n\nstat_count():\n\n\nThe default stat argument in geom_bar() is set to \"count\", which ‘counts the number of cases at each x position’, so it’s ideal for categorical variables (or factors).\nThe stat_count() function can also be used to create bar graphs using the geom argument.\nThe link between geom_geom_name(stat = \"stat_name\") and stat_stat_name(geom = \"geom_name\") is shown below:\n\n\n\n\nCode\nggp2_geom_bar &lt;- ggplot(data = penguins_bar,\n       aes(x = species)) +\n    geom_bar(aes(fill = species), \n        stat = \"count\") + \n    labs(title = \"geom_bar(stat = 'count')\")\nggp2_geom_bar\n\n\nggp2_stat_count &lt;- ggplot(data = penguins_bar,\n       aes(x = species)) +\n    stat_count(aes(fill = species), \n        geom = \"bar\") + \n    labs(title = \"stat_count(geom = 'bar')\")\nggp2_stat_count\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.4.2 geom_col()\n\ngeom_col():\n\n\nTo create a bar graph with geom_col(), the count variable needs to be computed before being mapped into the graph y aesthetic.\n\n\n\n\nCode\npenguins_bar |&gt; \n    # create column of counts \n    dplyr::count(species, name = \"count\") |&gt; \n    # map into x and y\n    ggplot(mapping = aes(x = species, y = count)) +\n    geom_col(aes(fill = species), \n        show.legend = FALSE) + \n    labs_bar +\n    labs(caption = \"*geom_col()\")\n    \n\n# compare to geom_bar()\nggp2_bar +\n  labs_bar"
  },
  {
    "objectID": "histograms.html#description",
    "href": "histograms.html#description",
    "title": "2  Histograms",
    "section": "2.1 Description",
    "text": "2.1 Description\nHistograms are a special kind of bar graph. The x axis is divided into ‘bins’ that cover the range of a variable’s values, and the height of the bars is the frequency (or count) of the value occurrence (displayed on the y axis).\nUnlike a typical bar graph, histograms can be used to visually asses the ‘normality’ (i.e. are the bars symmetrical, with a single peak in the middle of the x axis? Or do the bars form multiple peaks?) or ‘skewness’ (i.e., is there a long ‘tail’ of bars with decreasing length on either end of the x axis?) of a variable’s distribution."
  },
  {
    "objectID": "histograms.html#set-up",
    "href": "histograms.html#set-up",
    "title": "2  Histograms",
    "section": "2.2 Set up",
    "text": "2.2 Set up\n\nPACKAGES:\n\n\nInstall packages.\n\n\n\n\nCode\ninstall.packages(\"palmerpenguins\")\nlibrary(palmerpenguins) \nlibrary(ggplot2)\n\n\n\n\nDATA:\n\n\n\n\n\n\nArtwork by Allison Horst\n\n\n\nThe penguins data.\n\n\n\n\nCode\npenguins &lt;- palmerpenguins::penguins\nglimpse(penguins)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, …\n#&gt; $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen,…\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3…\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6…\n#&gt; $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181…\n#&gt; $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650…\n#&gt; $ sex               &lt;fct&gt; male, female, female, NA, female…\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 20…"
  },
  {
    "objectID": "histograms.html#grammar",
    "href": "histograms.html#grammar",
    "title": "2  Histograms",
    "section": "2.3 Grammar",
    "text": "2.3 Grammar\n\nCODE:\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nAssign flipper_length_mm to the x\nAdd the geom_histogram()\nAdjust the bins accordingly\n\n\n\n\nCode\nlabs_histogram &lt;- labs(\n  title = \"Adult foraging penguins\",\n  subtitle = \"Distribution of flipper length\",\n  x = \"Flipper length (millimeters)\")\n\nggp2_hist &lt;- ggplot(data = penguins,\n     aes(x = flipper_length_mm)) + \n     geom_histogram() \n\nggp2_hist + \n  labs_histogram\n\n\n\n\nGRAPH:\n\n\n\n\n\n\n\n\n\nThe standard number of bins is 30, but ‘you should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.’"
  },
  {
    "objectID": "frequency_polygons.html#description",
    "href": "frequency_polygons.html#description",
    "title": "Frequency polygons",
    "section": "Description",
    "text": "Description\nFrequency polygons are similar to histograms, but they use lines instead of bars to represent the variable’s distribution. The height of the line represents the frequency (or count) of the value occurrence.\nWhen viewing frequency polygons, we’re still assessing the shape of the lines for symmetry and skewness.."
  },
  {
    "objectID": "frequency_polygons.html#set-up",
    "href": "frequency_polygons.html#set-up",
    "title": "Frequency polygons",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "frequency_polygons.html#grammar",
    "href": "frequency_polygons.html#grammar",
    "title": "Frequency polygons",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "dot_plots.html#description",
    "href": "dot_plots.html#description",
    "title": "Dot plots",
    "section": "Description",
    "text": "Description\nDot-plots are similar to histograms and frequency polygons, except instead of using bars or lines, they use dots to represent the frequency (or count) of values for a given variable."
  },
  {
    "objectID": "dot_plots.html#set-up",
    "href": "dot_plots.html#set-up",
    "title": "Dot plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "dot_plots.html#grammar",
    "href": "dot_plots.html#grammar",
    "title": "Dot plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "density_plots.html#description",
    "href": "density_plots.html#description",
    "title": "Density plots",
    "section": "Description",
    "text": "Description\nDensity plots are similar to a histogram or frequency polygon, except the outline of the distribution has been ‘smoothed.’\nInstead of dividing the x axis into discrete ‘bins’ to create groupings for the variable’s values, density plots transform the distribution according to a kernel density estimate."
  },
  {
    "objectID": "density_plots.html#set-up",
    "href": "density_plots.html#set-up",
    "title": "Density plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "density_plots.html#grammar",
    "href": "density_plots.html#grammar",
    "title": "Density plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "violin_plots.html#description",
    "href": "violin_plots.html#description",
    "title": "Violin plots",
    "section": "Description",
    "text": "Description\nViolin plots will display the distribution of a single numeric (continuous) variable. If you’re trying to view the shape of a continuous distribution across the groups or levels of a categorical variable, check out grouped violin plots.\nThe violin plot is essentially a mirrored density plot, in which a smoothed distribution is plotted symmetrically across the x or y axis, creating a Rorschach-like inkblot area for the distribution:\n\n\n\n\n\nsource: Rorschach test, Wikipedia"
  },
  {
    "objectID": "violin_plots.html#set-up",
    "href": "violin_plots.html#set-up",
    "title": "Violin plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "violin_plots.html#grammar",
    "href": "violin_plots.html#grammar",
    "title": "Violin plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "box_plots.html#description",
    "href": "box_plots.html#description",
    "title": "Box plots",
    "section": "Description",
    "text": "Description\nBox plots (sometimes called box-and-whisker plots) use position, lines (vertical and horizontal), and points to convey a collection of summary statistics in a single graph."
  },
  {
    "objectID": "box_plots.html#set-up",
    "href": "box_plots.html#set-up",
    "title": "Box plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "box_plots.html#grammar",
    "href": "box_plots.html#grammar",
    "title": "Box plots",
    "section": "Grammar",
    "text": "Grammar\n\n\n\n\n\n\n\nMore Info\nBelow we provide more information on interpreting Box plots.\n\n\nIn ggplot2, values that fall more than 1.5 times the IQR are displayed as individual points (aka outliers). The lines extending from the bottom and top of the main box represent the last non-outlier value in the distribution.\n\n\nmovies dataInterpretCompare\n\n\n\nWe’ll use the ggplot2movies::movies data to create a box plot for movie length\n\n\n\n\nCode\ninstall.packages(\"ggplot2movies\")\nlibrary(ggplot2movies) \nlibrary(ggplot2)\n\n\n\n\nFilter ggplot2movies::movies to only include films after the made after 2000, and remove missing values from mpaa and budget\n\n\n\n\nCode\nmovies_box &lt;- ggplot2movies::movies |&gt; \n                dplyr::filter(year &gt; 2000 & \n                                mpaa != \"\" & \n                                    !is.na(budget))\nhead(movies_box)\n\n\n\n\n  \n\n\n\n\n\nBelow we create a box plot of the length variable using the methods described above:\n\n\n\n\nCode\nlabs_boxplot &lt;- labs(\n  title = \"IMDB Movie information and user ratings\",\n  y = \"Movie length (min)\", x = \"\")\nggp2_boxplot &lt;- ggplot(data = movies_box, \n           aes(x = \" \", \n               y = length)) +\n        geom_boxplot() \n\nggp2_boxplot + \n  labs_boxplot\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe table below shows the 25th percentile, the median, the 75th percentile, the IQR, and a histogram of the length variable from the movies_box dataset.\n\n\n\n\n\n\n\n25th\nMedian\n75th\nIQR\nHistogram\n\n\n\n\n92\n100\n113\n21\n▁▇▅▁▁\n\n\n\n\n\n\n\n\n\nThe figure below displays how each element in the box plot represents each of the statistics using lines and points.\n\n\n\n\n\n\n\n\n\n\nCompare the geom_point(), geom_freqpoly(), geom_histogram(), and geom_density() graphs of length from movie_box below to the geom_boxplot():"
  },
  {
    "objectID": "amounts.html",
    "href": "amounts.html",
    "title": "AMOUNTS",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nAmounts: These graphs display counts or simple summary statistics of one or two columns in a dataset."
  },
  {
    "objectID": "grp_bar_graphs.html#description",
    "href": "grp_bar_graphs.html#description",
    "title": "Grouped bar graphs",
    "section": "Description",
    "text": "Description\ngeom_col() allows us to display ‘grouped’ numerical values across levels (or groups) of a categorical variable. Grouped bar graphs assume the statistical measure (i.e., the value that the length of the bars will be derived from) is contained in a variable and mapped to the x or y aesthetic."
  },
  {
    "objectID": "grp_bar_graphs.html#set-up",
    "href": "grp_bar_graphs.html#set-up",
    "title": "Grouped bar graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grp_bar_graphs.html#grammar",
    "href": "grp_bar_graphs.html#grammar",
    "title": "Grouped bar graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "sum_bar_graphs.html#description",
    "href": "sum_bar_graphs.html#description",
    "title": "Summary bar graphs",
    "section": "Description",
    "text": "Description\nSummary bar graphs display the sum (or total) of a numerical variable across the levels of a second categorical variable. Color is used to make comparisons and distinguish between groups (or levels) of the categorical variable.\nIn ggplot2, we can create summary bar graphs with geom_bar()."
  },
  {
    "objectID": "sum_bar_graphs.html#set-up",
    "href": "sum_bar_graphs.html#set-up",
    "title": "Summary bar graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "sum_bar_graphs.html#grammar",
    "href": "sum_bar_graphs.html#grammar",
    "title": "Summary bar graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "sum_bar_graphs.html#more-info",
    "href": "sum_bar_graphs.html#more-info",
    "title": "Summary bar graphs",
    "section": "More Info",
    "text": "More Info\nNote that we didn’t have to write any code to calculate the total body_mass_g (displayed on the y axis) by island.\nThat’s because ggplot2 does this for us!\n\nSummaryIdentity vs. Count\n\n\n\nSUMMARY:\n\n\nIf we pass a categorical variable to the x (like island) and a continuous variable to y (like body_mass_kg), geom_col() will calculate the sum() of y by levels of x\n\n\nWe can see the underlying summary of budget using dplyr’s group_by() and summarise() functions.\n\n\n\n\nCode\npalmerpenguins::penguins |&gt; \n    dplyr::select(body_mass_g, island) |&gt; \n    tidyr::drop_na() |&gt; \n    # divide the mass value by 1000\n    dplyr::mutate(\n        body_mass_kg = body_mass_g / 1000\n    ) |&gt; \n    dplyr::group_by(island) |&gt;\n    dplyr::summarise(\n       `Total Penguin Body Mass (kg)` = sum(body_mass_kg)) |&gt;\n    dplyr::ungroup() |&gt; \n    dplyr::select(`Island` = island, \n        `Total Penguin Body Mass (kg)`)\n\n\n\n\n\n\n\n\n\n\nIsland\nTotal Penguin Body Mass (kg)\n\n\n\n\nBiscoe\n787.575\n\n\nDream\n460.400\n\n\nTorgersen\n189.025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSTATS:\n\n\nThe geom_bar() geom will also create grouped bar graphs, but we have to switch the stat argument to \"identity\".\n\n\n\n\nCode\nggplot(data = peng_sum_col,\n    aes(x = island,\n        y = body_mass_kg)) +\n    geom_col(aes(fill = island), \n        show.legend = FALSE,\n        stat = \"identity\")  +\n    labs_sum_col\n\n\n\n\n\n\n\n\n\n\n\ngeom_bar() vs. geom_col():\n\n\ngeom_bar() will map a categorical variable to the x or y and display counts for the discrete levels (see stat_count() for more info)\ngeom_col() will map both x and y aesthetics, and is used when we want to display numerical (quantitative) values across the levels of a categorical variable. geom_col() assumes these values have been created in their own column (see stat_identity() for more info)"
  },
  {
    "objectID": "overlapping_bar_graphs.html#desription",
    "href": "overlapping_bar_graphs.html#desription",
    "title": "Overlapping bar graphs",
    "section": "Desription",
    "text": "Desription\nOverlapping bar graphs display counts for categorical levels, resulting in bars differentiated by color and ‘stacked’ on top of each other.\nIn ggplot2, we can build overlapping bar graphs using the fill argument in geom_bar() or geom_col()"
  },
  {
    "objectID": "overlapping_bar_graphs.html#set-up",
    "href": "overlapping_bar_graphs.html#set-up",
    "title": "Overlapping bar graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "overlapping_bar_graphs.html#grammar",
    "href": "overlapping_bar_graphs.html#grammar",
    "title": "Overlapping bar graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "overlapping_bar_graphs.html#more-info",
    "href": "overlapping_bar_graphs.html#more-info",
    "title": "Overlapping bar graphs",
    "section": "More info",
    "text": "More info\nOverlapping bar graphs can also be built with geom_col().\ngeom_bar() has additional options for arranging overlapping bars. We can set the position argument to \"dodge\" or \"dodge2, depending on how we’d like the data displayed.\n\n\nposition = \"dodge\" preserves the vertical position of a geom while adjusting the horizontal position\nrequires the grouping variable to be be specified in the global or ⁠geom_⁠ layer\n\n\n\nworks without a grouping variable in a layer\nworks with bars and rectangles\nuseful for arranging graphs with variable widths.\n\n\ngeom_col()dodgedodge2\n\n\n\ngeom_col():\n\n\nTo build an overlapping bar graph with geom_col(), we need to create a column with the counts for flipper_length_mm and species in the dataset.\nCreate the penguins_col data:\n\n\n\n\nCode\npenguins_col &lt;- penguins_ovrlp |&gt;\n    count(species, flipper_length_mm, name = \"Count\")\n\n\n\n\nMap the counts to the y axis, flipper_length_mm to the x axis, and species to fill.\n\n\n\n\nCode\nlabs_col_ovrlp &lt;- labs(\n  title = \"Adult foraging penguins on Dream island\",\n  subtitle = \"built with 'geom_col()'\",\n  x = \"Flipper length (mm)\",\n  y = \"Count\",\n  fill = \"Species\")\nggp2_col_ovrlp &lt;- ggplot(data = penguins_col, \n    mapping = aes(y = Count, \n        x = flipper_length_mm, \n        fill = species)) + \n    geom_col()\nggp2_col_ovrlp + \n    labs_col_ovrlp\n\n\n\n\n\n\n\n\n\n\n\nCompare the two graphs below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndodge:\n\n\nCreate the penguins_dodge data.\n\n\n\n\nCode\npenguins_dodge &lt;- filter(penguins,\n                      !is.na(species) & \n                        !is.na(sex) &\n                            island == \"Dream\")\nglimpse(penguins_dodge)\n#&gt; Rows: 123\n#&gt; Columns: 8\n#&gt; $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, …\n#&gt; $ island            &lt;fct&gt; Dream, Dream, Dream, Dream, Drea…\n#&gt; $ bill_length_mm    &lt;dbl&gt; 39.5, 37.2, 39.5, 40.9, 36.4, 39…\n#&gt; $ bill_depth_mm     &lt;dbl&gt; 16.7, 18.1, 17.8, 18.9, 17.0, 21…\n#&gt; $ flipper_length_mm &lt;int&gt; 178, 178, 188, 184, 195, 196, 19…\n#&gt; $ body_mass_g       &lt;int&gt; 3250, 3900, 3300, 3900, 3325, 41…\n#&gt; $ sex               &lt;fct&gt; female, male, female, male, fema…\n#&gt; $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 20…\n\n\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nMap species to the x and island to group and fill\nInside the geom_bar() function, set position to \"dodge\"\n\n\n\n\nCode\nlabs_bar_dodge &lt;- labs(\n  title = \"Adult foraging penguins on Dream island\",\n  subtitle = \"position = 'dodge'\",\n  x = \"Sex\",\n  y = \"Count\",\n  fill = \"Species\")\nggp2_bar_dodge &lt;- ggplot(data = penguins_dodge,\n                    aes(x = sex, \n                        group = species, \n                        fill = species)) +\n                    geom_bar(\n                        position = \"dodge\")\nggp2_bar_dodge +\n  labs_bar_dodge\n\n\n\n\n\n\n\n\n\n\n\n\n\ndodge2:\n\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nMap species to x and island to fill\nInside geom_bar(), set position to \"dodge2\"\n\n\n\n\nCode\nlabs_bar_dodge2 &lt;- labs(\n  title = \"Adult foraging penguins on Dream island\",\n  subtitle = \"position = 'dodge2'\",\n  x = \"Sex\",\n  y = \"Count\",\n  fill = \"Species\")\nggp2_bar_dodge2 &lt;- ggplot(data = penguins_dodge,\n                    aes(x = sex, \n                        fill = species)) +\n                    geom_bar(\n                        position = \"dodge2\")\nggp2_bar_dodge2 +\n  labs_bar_dodge2\n\n\n\n\n\n\n\n\n\n\n\nCompare the two graphs below:"
  },
  {
    "objectID": "heatmaps.html#description",
    "href": "heatmaps.html#description",
    "title": "Heatmaps",
    "section": "Description",
    "text": "Description\nHeatmaps display quantitative values across an intersection of two categorical (or discrete) variables.\nThe intersecting cells contain variations of color saturation (i.e., the grade of purity or vividness) to represent the numerical values between groups.\nHeatmap legends should be positioned on top or bottom and justified horizontally to preserve shape and improve readability."
  },
  {
    "objectID": "heatmaps.html#set-up",
    "href": "heatmaps.html#set-up",
    "title": "Heatmaps",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "heatmaps.html#grammar",
    "href": "heatmaps.html#grammar",
    "title": "Heatmaps",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "heatmaps.html#more-info",
    "href": "heatmaps.html#more-info",
    "title": "Heatmaps",
    "section": "More info",
    "text": "More info\nIn addition to geom_tile(), heatmaps can also be created with the geom_raster() function.\n\ngeom_raster()\n\n\n\ngeom_raster():\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nAssign season to x, object to y, and occurrences to fill\nAdd the geom_raster()\nMove the legend to the bottom with theme(legend.position = \"bottom\")\n\n\n\n\nCode\nlabs_heatmap_raster &lt;- labs(\n  title = \"Bob Ross' plants & clouds\", \n  x = \"Episode\", \n  y = \"Plant/Cloud Object\", \n  fill = \"Occurrences\")\nggp2_heatmap_raster &lt;- ggplot(data = heatmap_ross, \n       aes(x = season, \n           y = object, \n           fill = occurrences)) + \n       geom_raster() + \n    theme(legend.position = \"bottom\")\nggp2_heatmap_raster + \n  labs_heatmap_raster"
  },
  {
    "objectID": "waffle_charts.html#description",
    "href": "waffle_charts.html#description",
    "title": "Waffle charts",
    "section": "Description",
    "text": "Description\nWaffle charts use color to display the levels that make up the values in a categorical variable. The counts for each level are divided into separate colors into a square or grid display.\nWaffle chart legends should be positioned on top or bottom and justified horizontally to preserve shape and improve readability.\nWe’ll build a waffle chart using the ggwaffle package."
  },
  {
    "objectID": "waffle_charts.html#set-up",
    "href": "waffle_charts.html#set-up",
    "title": "Waffle charts",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "waffle_charts.html#grammar",
    "href": "waffle_charts.html#grammar",
    "title": "Waffle charts",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "cleveland_dot_plots.html#description",
    "href": "cleveland_dot_plots.html#description",
    "title": "Cleveland dot plot",
    "section": "Description",
    "text": "Description\nA Cleveland dot plot displays differences in a numerical variable for different levels of a categorical variable.\nTypically, the graph contains two points representing the numerical value on the y axis, differentiated by color. A line connecting the two points represents the difference between the two categorical levels (the width of the line is the size of the difference)."
  },
  {
    "objectID": "cleveland_dot_plots.html#set-up",
    "href": "cleveland_dot_plots.html#set-up",
    "title": "Cleveland dot plot",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "cleveland_dot_plots.html#grammar",
    "href": "cleveland_dot_plots.html#grammar",
    "title": "Cleveland dot plot",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "cleveland_dot_plots.html#more-info",
    "href": "cleveland_dot_plots.html#more-info",
    "title": "Cleveland dot plot",
    "section": "More info",
    "text": "More info\nCleveland dot plots are also helpful when comparing multiple differences on a common scale.\n\nCommon scaleScales\n\n\n\nSCALE:\n\n\nRemove missing values from sex, bill_length_mm and bill_depth_mm, and group on sex and island to the calculate the median bill length and median bill depth. These variables need to have ‘showtime-ready’ names because they’ll be used in our facets. After un-grouping the data, pivot the new columns into a long (tidy) format with median_measure containing the name of the variable, and median_value containing the numbers.\nFinally, convert median_measure into a factor.\n\n\n\n\nCode\npeng_clev_dots2 &lt;- palmerpenguins::penguins |&gt;\n    dplyr::filter(!is.na(sex) & \n            !is.na(bill_length_mm) & \n                !is.na(bill_depth_mm)) |&gt;\n    dplyr::group_by(sex, island) |&gt;\n    dplyr::summarise(\n        `Median Bill Length` = median(bill_length_mm),\n        `Median Bill Depth` = median(bill_depth_mm)) |&gt;\n    dplyr::ungroup() |&gt; \n    tidyr::pivot_longer(cols = starts_with(\"Med\"), \n        names_to = \"median_measure\", \n        values_to = \"median_value\") |&gt; \n    dplyr::mutate(median_measure = factor(median_measure))\n#&gt; `summarise()` has grouped output by 'sex'. You can override\n#&gt; using the `.groups` argument.\nglimpse(peng_clev_dots2)\n#&gt; Rows: 12\n#&gt; Columns: 4\n#&gt; $ sex            &lt;fct&gt; female, female, female, female, fem…\n#&gt; $ island         &lt;fct&gt; Biscoe, Biscoe, Dream, Dream, Torge…\n#&gt; $ median_measure &lt;fct&gt; Median Bill Length, Median Bill Dep…\n#&gt; $ median_value   &lt;dbl&gt; 44.90, 14.50, 42.50, 17.80, 37.60, …\n\n\n\n\n\n\nscales:\n\n\nRe-create labels\nInitialize the graph with ggplot() and provide data\nMap the median_value to the x axis, and island to the y axis, but wrap island in forcats::fct_rev().\nAdd geom_line(), and map island to the group aesthetic. Set the linewidth to 0.75\nAdd geom_point() and map sex to color aesthetic. Set the size to 2.25\nAdd facet_wrap() and facet by median_measure, setting shrink to TRUE and scales to \"free_x\"\nMove the legend with theme(legend.position = \"top\")\n\n\n\n\nCode\nlabs_clev_dots2 &lt;- labs(\n    title = \"Penguin Measurements Differences\",\n    subtitle = \"Male and female penguins\",\n    x = \"Median Bill Length/Depth (mm)\",\n    y = \"Island\",\n    color = \"Sex\")\n\nggp2_clev_dots2 &lt;- ggplot(data = peng_clev_dots2,\n    mapping = aes(x = median_value,\n        y = fct_rev(island))) +\n    geom_line(aes(group = island),\n        linewidth = 0.55) +\n    geom_point(aes(color = sex),\n        size = 2) +\n    facet_wrap(. ~ median_measure,\n        shrink = TRUE, nrow = 2) +\n    theme(legend.position = \"top\")\n\nggp2_clev_dots2 +\n    labs_clev_dots2\n\n\n\n\n\n\n\n\n\n\n\nCAUTION when using scales = \"free_x\": The graph below shows that the median bill length and depth is larger for male penguins on all three islands, but the magnitude of the differences should be interpreted with caution because the length of the lines can’t be directly compared!\n\n\n\n\nCode\nlabs_clev_dots2 &lt;- labs(\n    title = \"Penguin Measurements Differences\",\n    subtitle = \"Male and female penguins\",\n    x = \"Median Bill Length/Depth (mm)\",\n    y = \"Island\",\n    color = \"Sex\")\n\nggp2_clev_dots2_free_x &lt;- ggplot(data = peng_clev_dots2,\n    mapping = aes(x = median_value,\n        y = fct_rev(island))) +\n    geom_line(aes(group = island),\n        linewidth = 0.55) +\n    geom_point(aes(color = sex),\n        size = 2) +\n    facet_wrap(. ~ median_measure,\n        shrink = TRUE, nrow = 2,\n        scales = \"free_x\") +\n    theme(legend.position = \"top\")\n\nggp2_clev_dots2_free_x +\n    labs_clev_dots2"
  },
  {
    "objectID": "proportions.html",
    "href": "proportions.html",
    "title": "PROPORTIONS",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nProportions: These graphs display stratified counts, percentages, or part-to-whole relationships of values within variables (or between variables)."
  },
  {
    "objectID": "diverging_bar_graphs.html#description",
    "href": "diverging_bar_graphs.html#description",
    "title": "Diverging bar graphs",
    "section": "Description",
    "text": "Description\nIf you have two proportions that contain positive and negative values, consider using diverging bars with geom_bar().\nUnlike a standard or stacked bar graphs, diverging bar graphs display positive and negative quantities on both sides of a reference or baseline value (zero in this example). Color, length and position are used to compare the quantities across categorical levels (and within variable values).\n\nHorizontal barsVertical bars\n\n\n\n\n\n\n\n\n\n\n\n\nFor example, we can use the length of the bar from the reference line to compare disapproval estimates across all months (i.e., comparing red bars to each other).\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also compare approval vs. disapproval for each month (i.e., compare the blue vs. red bars to each other within each month)."
  },
  {
    "objectID": "diverging_bar_graphs.html#set-up",
    "href": "diverging_bar_graphs.html#set-up",
    "title": "Diverging bar graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "diverging_bar_graphs.html#grammar",
    "href": "diverging_bar_graphs.html#grammar",
    "title": "Diverging bar graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "diverging_bar_graphs.html#more-info",
    "href": "diverging_bar_graphs.html#more-info",
    "title": "Diverging bar graphs",
    "section": "More info",
    "text": "More info\nFor vertically arranged bars, we switch the x and y axis variables.\n\nVertically arranged bars\n\n\n\nVertical bars:\n\n\nCreate labels with labs()\nMap the month_avg to the x and month to the y\nInside geom_bar()\n\nmap poll to fill\nuse stat = \"identity\" and width = .5\n\nAdd scale_y_continuous() to manually set the limits and format the axis with scales::percent\n\n\n\n\nCode\nlabs_geom_bar_diverg_vert &lt;- labs(\n  title = \"Trump Approval Ratings\",\n  subtitle = \"From 'How Popular is Donald Trump'\",\n  x = \"Monthly average percent\",\n  y = \"Month\",\n  fill = \"Estimate\")\nggp2_bar_diverg_vert &lt;- ggplot(\n  data = trump_approval_diverg,\n      aes(x = month_avg, y =  month)) +\n  geom_bar(\n      aes(fill = poll), \n        stat = \"identity\", width = .5) + \n  scale_x_continuous(limits = c(-1, 1), \n        labels = scales::percent)\nggp2_bar_diverg_vert + \n  labs_geom_bar_diverg_vert"
  },
  {
    "objectID": "stacked_filled_density_graphs.html#description",
    "href": "stacked_filled_density_graphs.html#description",
    "title": "Stacked densities",
    "section": "Description",
    "text": "Description\nDensity graphs are typically used to visualize the distribution of a single variable, but stacked density graphs are great for visualizing how proportions vary across numeric (continuous) variables."
  },
  {
    "objectID": "stacked_filled_density_graphs.html#set-up",
    "href": "stacked_filled_density_graphs.html#set-up",
    "title": "Stacked densities",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "stacked_filled_density_graphs.html#grammar",
    "href": "stacked_filled_density_graphs.html#grammar",
    "title": "Stacked densities",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "mosaic_plots.html#description",
    "href": "mosaic_plots.html#description",
    "title": "Mosaic plots",
    "section": "Description",
    "text": "Description\nA mosaic plot is similar to a stacked bar graph, but instead of only relying on height and color to display the relative amount for each value, mosaic plots also use width.\nMosaic plot legends should be positioned on top or bottom and justified horizontally to preserve shape and improve readability.\nWe can build mosaic plots using the ggmosaic package."
  },
  {
    "objectID": "mosaic_plots.html#set-up",
    "href": "mosaic_plots.html#set-up",
    "title": "Mosaic plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "mosaic_plots.html#grammar",
    "href": "mosaic_plots.html#grammar",
    "title": "Mosaic plots",
    "section": "Grammar",
    "text": "Grammar\n\n\nIt’s a good idea to adjust the fig-height and fig-width of your graph\n\n\nDetails\n\n\n\nDETAILS:\n\n\nWe’ve re-written the labels for the mosaic plot (ggp2_mosaic) to illustrate what’s happening in the aes() of geom_mosaic().\n\n\n\n\n\n\n\n\nunruly_child\nNo\nSomewhat\nVery\n\n\n\n\nVery\n152\n125\n74\n\n\nSomewhat\n296\n54\n1\n\n\nNo\n144\n3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe table above displays the counts for each combined response. As we can see, the counts are represented by height and width in the graph."
  },
  {
    "objectID": "mosaic_plots.html#more-info",
    "href": "mosaic_plots.html#more-info",
    "title": "Mosaic plots",
    "section": "More info",
    "text": "More info\nI recommend reading the ggmosaic vignette, particularly the sections on ordering and conditioning.\n\n\n\n\nunruly_child\nNo\nSomewhat\nVery\n\n\n\n\nVery\n193\n119\n39\n\n\nSomewhat\n204\n123\n24\n\n\nNo\n102\n38\n7\n\n\n\n\n\n\nTwo variablesFacets\n\n\n\n\n\n\n\n\nTWO VARIABLES:\n\n\nBelow is another example of a two-variable mosaic plot, mapping the product() variables as unruly_child and recline_rude, and the fill variable as recline_rude.\nOnce again we can see the counts for each category in the cross-tabulation:\n\n\n\n\nCode\n# build 2-variable mosiac plot\nlabs_mosaic_2var &lt;- labs(\n  title = \"In general...is it rude to...\", \n  subtitle = \"2-Variable plot\",\n  x = \"... recline your seat on a plane?\",\n  y = \"...knowingly bring unruly children on a plane?\",\n  fill = \"recline_rude responses\")\n\nggp2_mosaic_2var &lt;- ggplot(data = fly_mosaic) +\n  geom_mosaic(aes(\n    x = product(unruly_child, recline_rude),\n    fill = recline_rude)) +\n  ggmosaic::theme_mosaic(base_size = 10) + \n  theme(legend.position = \"bottom\")\n  \nggp2_mosaic_2var + \n    labs_mosaic_2var\n\n\n\n\n\n\n\n\n\n\n\nFor conditional variables, we map the product() variable as unruly_child and the fill variable as baby, but include a conds variable (as product(recline_rude)).\n\n\n\n\nCode\n# build conditional mosiac plot\nlabs_mosaic_cond &lt;- labs(\n  title = \"In general...is it rude to...\", \n  subtitle = \"Conditional plot\",\n  x = \"...recline your seat on a plane?\",\n  y = \"...knowingly bring unruly children on a plane?\",\n  fill = \"unruly_child responses\")\nggp2_mosaic_cond &lt;- ggplot(data = fly_mosaic) +\n  geom_mosaic(aes(\n    x = product(unruly_child), # product variable\n    fill = unruly_child,\n    conds = product(recline_rude))) + # conditional variable\n  ggmosaic::theme_mosaic(base_size = 10) + \n  theme(legend.position = \"bottom\")\n\nggp2_mosaic_cond + \n    labs_mosaic_cond\n\n\n\n\n\n\n\n\n\n\n\n\n\nFACETS:\n\n\nAnother option for including a conditioning variable is including facets. In the example below we use recline_rude in both x and fill (remember to wrap recline_rude in product()).\nThe divider argument let’s us control the spine partitions (vertically and horizontally). Below are the two vertical orientation options for the divider argument.\n\n\n\n\n\n\n\n\n\n\n\nThe two horizontal orientation options make the axis text harder to read, so these need to be manipulated manually."
  },
  {
    "objectID": "pie_charts.html#description",
    "href": "pie_charts.html#description",
    "title": "Pie charts",
    "section": "Description",
    "text": "Description\n“In general, pie charts work well when the goal is to emphasize simple fractions, such as one-half, one-third, or one-quarter.”\n“They also work well when we have very small datasets.” - Claus O. Wilke, Fundamentals of Data Visualization (2019)\nPie-charts are ideal for comparing the proportions of categorical variable values, and we can build pie-charts using the ggpubr package."
  },
  {
    "objectID": "pie_charts.html#set-up",
    "href": "pie_charts.html#set-up",
    "title": "Pie charts",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "pie_charts.html#grammar",
    "href": "pie_charts.html#grammar",
    "title": "Pie charts",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "treemaps.html#description",
    "href": "treemaps.html#description",
    "title": "Treemaps",
    "section": "Description",
    "text": "Description\nTreemaps display proportionally divided rectangular hierarchies for levels of categorical variables. The layout consists of ‘squarified’ tiles, which display the relative contribution of each categorical value to the overall graph space.\nWe’ll build a treemap using the treemapify package. Also check out mosaic plots."
  },
  {
    "objectID": "treemaps.html#set-up",
    "href": "treemaps.html#set-up",
    "title": "Treemaps",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "treemaps.html#grammar",
    "href": "treemaps.html#grammar",
    "title": "Treemaps",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "treemaps.html#more-info",
    "href": "treemaps.html#more-info",
    "title": "Treemaps",
    "section": "More info",
    "text": "More info\ntreemapify has multiple options for building treemaps. We cover a few of these below, but you should check out the package vignette.\n\nSubgroupSubgroup 2\n\n\n\nSUBGROUP:\n\n\nggplot2 build layers in the order they’re written, so it’s advised to build the subgroups in order from “from deepest to shallowest”, with subgroups2 first (ending on subgroup)\n\nAdd geom_treemap_subgroup2_border()\n\nSet the size and color\n\nAdd geom_treemap_subgroup2_text()\n\nplace: this controls where the boxes start\n\ncolor: text color\n\nmin.size: the minimum font size (when re-sizing)\n\nalpha: opacity\n\nfontface: itlalic/bond\n\nfamily: \"sans\"/\"sansserif\"/\"mono\"\n\n\nSee full list of arguments here.\n\n\n\n\nCode\nggp2_tm_subgroup &lt;- ggp2_treemap +\n    treemapify::geom_treemap_subgroup2_border(\n           color = \"#02577A\",\n           size = 4.0) + \n       treemapify::geom_treemap_subgroup2_text(\n           place = \"center\",\n           alpha = 0.65,\n           color = \"#02577A\",\n           min.size = 0,\n           family = \"sans\")\nggp2_tm_subgroup +\n  labs_treemap\n\n\n\n\n\n\n\n\n\n\n\n\n\nSUBGROUP 2:\n\n\nAdd geom_treemap_subgroup_border()\n\nSet the size and color\n\nAdd geom_treemap_subgroup_text()\n\nplace: this controls where the boxes start\n\ncolor: text color\n\nmin.size: the minimum font size (when re-sizing)\n\nalpha: opacity\n\nfontface: itlalic/bond\n\nfamily: \"sans\"/\"sansserif\"/\"mono\"\n\n\n\n\n\nCode\nggp2_tm_subgroup2 &lt;- ggp2_tm_subgroup + \n       treemapify::geom_treemap_subgroup_border(\n           color = \"#ffffff\", \n           size = 4) + \n       treemapify::geom_treemap_subgroup_text(\n           place = \"topleft\",\n           alpha = 0.65,\n           grow = TRUE,\n           color = \"#ffffff\",\n           min.size = 0,\n           family = \"mono\",\n           fontface = \"bold\")\n\nggp2_tm_subgroup2 + \n  labs_treemap"
  },
  {
    "objectID": "distributions.html",
    "href": "distributions.html",
    "title": "DISTRIBUTIONS",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nDistributions: these graphs display the shape of a variable’s values (good for assessing normalcy, skewness, kurtosis, etc.)"
  },
  {
    "objectID": "overlapping_histograms.html#description",
    "href": "overlapping_histograms.html#description",
    "title": "Overlapping histograms",
    "section": "Description",
    "text": "Description\nOverlapping histograms allow us to compare distributions across the groups of a categorical (or ordinal) variable."
  },
  {
    "objectID": "overlapping_histograms.html#set-up",
    "href": "overlapping_histograms.html#set-up",
    "title": "Overlapping histograms",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "overlapping_histograms.html#grammar",
    "href": "overlapping_histograms.html#grammar",
    "title": "Overlapping histograms",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "overlapping_frequency_polygons.html#description",
    "href": "overlapping_frequency_polygons.html#description",
    "title": "Overlapping frequency polygons",
    "section": "Description",
    "text": "Description\nOverlapping frequency polygons are similar to overlapping histograms–they allow us to compare distributions of a continuous variable across the levels of a categorical variable.\nInstead of using bars, frequency polygons use lines to show the shape of the distribution."
  },
  {
    "objectID": "overlapping_frequency_polygons.html#set-up",
    "href": "overlapping_frequency_polygons.html#set-up",
    "title": "Overlapping frequency polygons",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "overlapping_frequency_polygons.html#grammar",
    "href": "overlapping_frequency_polygons.html#grammar",
    "title": "Overlapping frequency polygons",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "overlapping_dot_plots.html#description",
    "href": "overlapping_dot_plots.html#description",
    "title": "Overlapping dot plots",
    "section": "Description",
    "text": "Description\nOverlapping dot plots display distributions of a continuous variable across the levels of a categorical variable.\nTo adjust the dot plot display to look similar to a histogram or frequency polygon, change the method and binposition arguments."
  },
  {
    "objectID": "overlapping_dot_plots.html#set-up",
    "href": "overlapping_dot_plots.html#set-up",
    "title": "Overlapping dot plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "overlapping_dot_plots.html#grammar",
    "href": "overlapping_dot_plots.html#grammar",
    "title": "Overlapping dot plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "beeswarm_plots.html#description",
    "href": "beeswarm_plots.html#description",
    "title": "Beeswarm plots",
    "section": "Description",
    "text": "Description\nThe beeswarm plot uses points to display the distribution of a continuous variable across the levels of a categorical variable.\nThe points are grouped by level, and the shape (or swarm) of the distribution is mirrored above and below the quantitative axis (similar to a violin plot).\nWe can create beeswarm plot using geom_jitter() or the ggbeeswarm package."
  },
  {
    "objectID": "beeswarm_plots.html#set-up",
    "href": "beeswarm_plots.html#set-up",
    "title": "Beeswarm plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "beeswarm_plots.html#grammar",
    "href": "beeswarm_plots.html#grammar",
    "title": "Beeswarm plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "beeswarm_plots.html#more-info",
    "href": "beeswarm_plots.html#more-info",
    "title": "Beeswarm plots",
    "section": "More info",
    "text": "More info\nBelow we cover some additional arguments and methods for beeswarm plots.\n\n\nSet the point shape to 21 to control the fill and color\n\n\nmethodsidecexgeom_jitter()\n\n\n\nMETHOD:\n\n\nUse method to adjust the shape of the beeswarm (swarm, compactswarm, hex, square, center, or centre)\n\n\n\n\n\nCode\nggp2_compact_swarm &lt;- ggplot(data = peng_beeswarm,\n    mapping = aes(x = species,\n                  y = bill_ratio,\n                color = species)) +\n    ggbeeswarm::geom_beeswarm(\n      aes(fill = species),\n        method = 'compactswarm', \n        dodge.width = 0.5,\n        shape = 21,\n        color = \"#ffffff\",\n        alpha = 2/3, size = 1.7,\n        show.legend = FALSE) \nggp2_compact_swarm + \n    # add labels\n    labs_beeswarm\n\n\n\n\n\n\n\n\n\n\n\n\n\nSIDE:\n\n\nFor a beeswarm that falls across the vertical axis, use the side argument.\n\n\n\n\nCode\nggp2_rside_swarm &lt;- ggplot(data = peng_beeswarm,\n    mapping = aes(x = species,\n                  y = bill_ratio,\n                color = species)) +\n    ggbeeswarm::geom_beeswarm(\n      aes(fill = species),\n        side = 1, # right/upwards\n        shape = 21,\n        color = \"#ffffff\",\n        alpha = 2/3, \n        size = 1.7,\n        show.legend = FALSE) \nggp2_rside_swarm + \n    # add labels\n    labs_beeswarm\n\n\n\n\n\n\n\n\n\n\n\n\n\nCEX:\n\n\nThe cex argument controls the “scaling for adjusting point spacing”\n\n\n\n\nCode\nggp2_beeswarm_cex &lt;- ggplot(data = peng_beeswarm,\n    mapping = aes(x = species,\n                  y = bill_ratio,\n                color = species)) +\n    ggbeeswarm::geom_beeswarm(\n      aes(fill = species),\n        cex = 1.6,\n        shape = 21,\n        color = \"#ffffff\",\n        alpha = 2/3, \n        size = 1.7,\n        show.legend = FALSE) \nggp2_beeswarm_cex + \n    # add labels\n    labs_beeswarm\n\n\n\n\n\n\n\n\n\n\n\n\n\nJITTER:\n\n\nWe can also create a beeswarm using the geom_jitter() and setting the height and width.\n\n\n\n\nCode\nggp2_jitter_swarm &lt;- ggplot(data = peng_beeswarm,\n    mapping = aes(x = species,\n        y = bill_ratio,\n        color = species)) +\n    geom_jitter(\n        aes(fill = species),\n        height = 0.05,\n        width = 0.11,\n        shape = 21,\n        color = \"#ffffff\",\n        alpha = 2 / 3,\n        size = 1.7,\n        show.legend = FALSE)\nggp2_jitter_swarm + \n    # add labels\n    labs_beeswarm"
  },
  {
    "objectID": "overlapping_stacked_density_plots.html#description",
    "href": "overlapping_stacked_density_plots.html#description",
    "title": "Overlapping density plot",
    "section": "Description",
    "text": "Description\nDensity plots are smoothed version(s) of histogram(s). They can are great for comparing the distributions of a continuous variable across the levels of a categorical variable.\ngeom_density() creates a kernel density estimate. The default position argument is \"identity\", which takes the data as is. However, we can change position to \"stack\" to display overlapping distributions."
  },
  {
    "objectID": "overlapping_stacked_density_plots.html#set-up",
    "href": "overlapping_stacked_density_plots.html#set-up",
    "title": "Overlapping density plot",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "overlapping_stacked_density_plots.html#grammar",
    "href": "overlapping_stacked_density_plots.html#grammar",
    "title": "Overlapping density plot",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "overlapping_stacked_density_plots.html#more-info",
    "href": "overlapping_stacked_density_plots.html#more-info",
    "title": "Overlapping density plot",
    "section": "More info",
    "text": "More info\nggplot2 has multiple options for overlapping density plots, so which one to use will depend on how you’d like to display the relative distributions in your data. We’ll cover three options below:\n\n\"stack\"after_stat(count)\"fill\"\n\n\n\nSTACK:\n\n\nIf we change the position to \"stack\" we can see the smoothed estimates are ‘stacked’ on top each other (and the y axis shifts slightly).\n\n\n\n\nCode\nlabs_stack_density &lt;- labs(\n    title = \"Adult foraging penguins\",\n    x = \"Flipper length (millimeters)\",\n    fill = \"Sex\")\nggp2_stack_density &lt;- ggplot(data = peng_density,\n    mapping = aes(x = flipper_length_mm,\n               fill = sex)) +\n    geom_density(position = \"stack\",\n                 alpha = 1 / 3)\nggp2_stack_density +\n    labs_stack_density\n\n\n\n\n\n\n\n\n\n\n\nSetting position to 'stack' loses marginal densities\n\n\n\n\nAFTER STAT:\n\n\nIf we include after_stat(count) as one of our mapped aesthetics, the mapping is postponed until after statistical transformation, and uses the density * n instead of the default density.\n\n\n\n\nCode\nlabs_after_stat_density &lt;- labs(\n  title = \"Adult foraging penguins\",\n  x = \"Flipper length (millimeters)\", \n  fill = \"Sex\")\nggp2_after_stat_density &lt;- ggplot(data = peng_density, \n       aes(x = flipper_length_mm, \n           after_stat(count),\n           fill = sex)) +\n      geom_density(position = \"stack\", \n                   alpha = 1/3) \nggp2_after_stat_density + \n  labs_after_stat_density\n\n\n\n\n\n\n\n\n\n\n\nAdding after_stat(count) ‘preserves marginal densities.’, which result in more a interpretable y axis (depending on the audience)\n\n\n\n\nFILL:\n\n\nUsing after_stat(count) with position = \"fill\" creates in a conditional density estimate.\n\n\n\n\nCode\nlabs_fill_density &lt;- labs(\n  title = \"Adult foraging penguins\",\n  x = \"Flipper length (millimeters)\", \n  fill = \"Sex\")\nggp2_fill_density &lt;- ggplot(data = peng_density, \n       aes(x = flipper_length_mm, \n           after_stat(count),\n           fill = sex)) +\n      geom_density(position = \"fill\", \n                   alpha = 1/3) \nggp2_fill_density + \n  labs_fill_density\n\n\n\n\n\n\n\n\n\n\n\nThis results in a y axis ranging from 0-1, and the area filled with the relative proportional values."
  },
  {
    "objectID": "ridgeline_plots.html#description",
    "href": "ridgeline_plots.html#description",
    "title": "Ridgeline plots",
    "section": "Description",
    "text": "Description\nIf we want to plot density curves but retain the interpretability of the axes, consider comparing multiple distributions using the ggridges package."
  },
  {
    "objectID": "ridgeline_plots.html#set-up",
    "href": "ridgeline_plots.html#set-up",
    "title": "Ridgeline plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "ridgeline_plots.html#grammar",
    "href": "ridgeline_plots.html#grammar",
    "title": "Ridgeline plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grouped_box_plots.html#description",
    "href": "grouped_box_plots.html#description",
    "title": "Grouped box plots",
    "section": "Description",
    "text": "Description\nGrouped box plots display five different statistical measures across a series of categories, or groups, of a discrete, ordinal, or interval variable.\nThe five statistical measures are 1) the first quartile, 2) the second quartile, and 3) the third quartile. The fourth and fifth values are the largest/smallest values no further than 1.5 X inter-quartile range from the hinges."
  },
  {
    "objectID": "grouped_box_plots.html#set-up",
    "href": "grouped_box_plots.html#set-up",
    "title": "Grouped box plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grouped_box_plots.html#grammar",
    "href": "grouped_box_plots.html#grammar",
    "title": "Grouped box plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grouped_box_plots.html#more-info",
    "href": "grouped_box_plots.html#more-info",
    "title": "Grouped box plots",
    "section": "More info",
    "text": "More info\n\nNotchesOutliers\n\n\n\nNOTCHES:\n\n\nAdd notches to the box plot using the notch = TRUE and notchwidth arguments.\n\n\n\n\nCode\nggp2_grp_box_notch &lt;- ggplot(data = peng_box,\n       aes(x = island, \n           y = bill_length_mm, \n        fill = island)) +\n  geom_boxplot(\n      notch = TRUE, \n      notchwidth = 0.85, \n      alpha = 2/3, \n      show.legend = FALSE) \nggp2_grp_box_notch + \n    labs_grp_boxplots\n\n\n\n\n\n\n\n\n\n\n\n\n\nOUTLIERS:\n\n\nBox plots display outliers using points, and we can change the color these using the outlier.colour argument. Inside the geom_boxplot(), we map island to color and set outlier.colour to NULL:\n\n\n\n\nCode\nggp2_grp_box_outliers &lt;- ggplot(data = peng_box,\n       aes(x = island, \n           y = bill_length_mm,\n           fill = island)) +\n  geom_boxplot(aes(color = island),\n      outlier.colour = NULL, \n      outlier.size = 2,\n      notch = TRUE, \n      notchwidth = 0.85, \n      alpha = 2/3, \n      show.legend = FALSE) \nggp2_grp_box_outliers + \n    labs_grp_boxplots"
  },
  {
    "objectID": "grouped_violin_plots.html#description",
    "href": "grouped_violin_plots.html#description",
    "title": "Grouped violin plots",
    "section": "Description",
    "text": "Description\nA ‘violin plot’ is a variation of a density or ridgeline plot, where the distribution is plotted symmetrically, creating a two-sided, smoothed distribution."
  },
  {
    "objectID": "grouped_violin_plots.html#set-up",
    "href": "grouped_violin_plots.html#set-up",
    "title": "Grouped violin plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grouped_violin_plots.html#more-info",
    "href": "grouped_violin_plots.html#more-info",
    "title": "Grouped violin plots",
    "section": "More info",
    "text": "More info\n\nChange the shape of the line with linetype and linewidth.\n\nQuartilesKernelBandwidth\n\n\n\n\ndraw_quantiles:\n\n\nWe can include lines for the 25th, 50th, and 75th quartiles using the draw_quantiles argument.\n\n\n\n\nCode\nggplot(data = peng_violin,\n       aes(x = island, \n           y = bill_length_mm, \n        fill = island)) +\n  geom_violin(\n      draw_quantiles = c(0.25, 0.5, 0.75),\n      alpha = 1/2, \n      linewidth = 0.5, \n      show.legend = FALSE) \n\n\n\n\n\n\n\n\n\n\n\n\n\nkernel:\n\n\nThe kernel argument let’s us change the “kernel density estimate” used to create the violin shape. The possible kernel density estimates are \"gaussian\", \"epanechnikov\", \"rectangular\", \"triangular\", \"biweight\", \"cosine\", and \"optcosine\"\n\n\n\n\nCode\nggplot(data = peng_violin,\n       aes(x = island, \n           y = bill_length_mm, \n        fill = island)) +\n  geom_violin(alpha = 1/2, \n      linewidth = 0.5, \n      kernel = \"rectangular\",\n      show.legend = FALSE) \n\n\n\n\n\n\n\n\n\n\n\n\n\nbw:\n\n\nWe can directly adjust the shape of the violin with the bw argument, which is the standard deviation of the smoothing kernel. The trim argument trim(s) the tails of the violins to the range of the data.\n\n\n\n\nCode\n# bw of 0.5\ngrp_violin_bw0p5 &lt;- ggplot(data = peng_violin,\n       aes(x = island, \n           y = bill_length_mm, \n        fill = island)) +\n  geom_violin(bw = 0.5, \n      alpha = 2/3, \n      trim = TRUE,\n      show.legend = FALSE) \ngrp_violin_bw0p5 + \n    labs_grp_violin + \n    labs(caption = \"bw = 0.5\")\n# bw of 4.5\ngrp_violin_bw4p5 &lt;- ggplot(data = peng_violin,\n       aes(x = island, \n           y = bill_length_mm, \n        fill = island)) +\n  geom_violin(bw = 4.5, \n      alpha = 2/3, \n      trim = TRUE,\n      show.legend = FALSE) \ngrp_violin_bw4p5 + \n    labs_grp_violin + \n    labs(caption = \"bw = 4.5\")"
  },
  {
    "objectID": "raincloud_plots.html#description",
    "href": "raincloud_plots.html#description",
    "title": "Raincloud plots",
    "section": "Description",
    "text": "Description\nRaincloud plots are a combination of density graph, a box plot, and a beeswarm (or jitter) plot, and are used to compare distributions of quantitative/numerical variables across the levels of a categorical (or discrete) grouping variable.\nWe can use the raincloudplots package to create raincloud plots, or they can be built using the ggdist package and geoms from ggplot2."
  },
  {
    "objectID": "raincloud_plots.html#set-up",
    "href": "raincloud_plots.html#set-up",
    "title": "Raincloud plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "raincloud_plots.html#grammar-raincloudplots",
    "href": "raincloud_plots.html#grammar-raincloudplots",
    "title": "Raincloud plots",
    "section": "Grammar (raincloudplots)",
    "text": "Grammar (raincloudplots)"
  },
  {
    "objectID": "raincloud_plots.html#more-info",
    "href": "raincloud_plots.html#more-info",
    "title": "Raincloud plots",
    "section": "More info",
    "text": "More info\n\nBox-plotDensityPoints\n\n\n\nggplot2::geom_boxplot()\n\n\nCreate labels with labs()\nInitialize the graph with ggplot() and provide data\nFor the first layer, we create a box plot with geom_boxplot(), but include notches and remove the outliers.\n\n\n\n\nCode\nlabs_raincloud_2 &lt;- ggplot2::labs(\n    title = \"Flipper length of Palmer penguins\",\n         x = \"Flipper length (mm)\",\n         y = \"Species\")\nggp2_box &lt;- ggplot(peng_raincloud,\n    aes( x = flipper_length_mm, y = species)) + \n  geom_boxplot(aes(fill = species),\n    notch = TRUE, \n    notchwidth = 0.9,\n    width = 0.15, \n    outlier.shape = NA,\n    show.legend = FALSE)\nggp2_box + \n    labs_raincloud_2\n\n\n\n\n\n\n\n\n\n\n\n\n\nggdist::stat_halfeye()\n\n\nWe then add a horizontal density curve with ggdist::stat_halfeye(), mapping species to fill, and adjusting the size and shape of the density curve and shifting it slightly above the box plot.\n\n\n\n\nCode\nggp2_stat_halfeye &lt;- ggp2_box +\n  ggdist::stat_halfeye(aes(fill = species),\n    adjust = 0.6, # shape = adjust * density estimator\n    .width = 0, # can use probabilities or 0\n    point_colour = NA, # removes the point in center\n    orientation = \"horizontal\", # like the box plot\n    height = 0.5, # height of curve\n    justification = -0.3, # shift vertically above box\n    show.legend = FALSE # don't need this \n) \nggp2_stat_halfeye + \n    labs_raincloud_2\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2::geom_point()\n\n\nThe final layer is a geom_point(), mapping fill to species and setting position to position_jitter(). Additional adjustments to the points include:\n\nUsing shape = 21, we can color the outside of the point (white makes it appear to glow).\nManually set the height, which refers to the vertical area for the points\n\n\n\n\n\nCode\nggp2_jitter &lt;- ggp2_stat_halfeye + \n    geom_point(aes(fill = species),\n        position = position_jitter(\n          seed = 321, \n          height = .07),\n            shape = 21, \n            color = \"#ffffff\", \n            alpha = 1/3, \n            size = 1.8,\n            show.legend = FALSE) \nggp2_jitter + \n    labs_raincloud_2"
  },
  {
    "objectID": "raincloud_plots.html#more-examples-resources",
    "href": "raincloud_plots.html#more-examples-resources",
    "title": "Raincloud plots",
    "section": "More examples & resources",
    "text": "More examples & resources\n\nPoint shape#TidyTuesday exampleMore resources\n\n\n\nPoint shape\n\n\nCédric Scherer covered raincloud plots in this great write-up for #TidyTuesday.\nCédric also covers some alternative methods for plotting the points (I particularly like using bands instead of points when displaying the rainclouds vertically).\nWe can switch to this layout by applying ggplot2::coord_flip() to the ggp2_stat_halfeye layer, then adding geom_point() with shape set to 95\n\n\n\n\nCode\nggp2_stat_halfeye + \n    ggplot2::coord_flip() + \nggplot2::geom_point(\n    shape = 95,\n    size = 8,\n    alpha = 0.2) + \n    theme(legend.position = \"none\") + \n    labs_raincloud_2\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolished Graph\n\n\nThe code to re-create the #TidyTuesday graph is contained in this gist.\n\n\n\n\n\n\n\n\n\nMORE RESOURCES\n\n\n\nRaincloud plots: a multi-platform tool for robust data visualization. 1\nShape and point sizes in R. 2\nRainCloudPlots package on GitHub. 3"
  },
  {
    "objectID": "dates_and_times.html",
    "href": "dates_and_times.html",
    "title": "DATES & TIMES",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nDates & times: These graphs display changes in quantitative or categorical variables over a dimension of time (date-time, date, year, month, quarter, etc.)."
  },
  {
    "objectID": "line_graphs.html#description",
    "href": "line_graphs.html#description",
    "title": "Line graphs",
    "section": "Description",
    "text": "Description\nLine graphs display changes of a numeric quantitative variable (on the y axis) over time (on the x axis)."
  },
  {
    "objectID": "line_graphs.html#set-up",
    "href": "line_graphs.html#set-up",
    "title": "Line graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "line_graphs.html#grammar",
    "href": "line_graphs.html#grammar",
    "title": "Line graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grp_line_graphs.html#description",
    "href": "grp_line_graphs.html#description",
    "title": "Grouped line graphs",
    "section": "Description",
    "text": "Description\nGrouped line graphs use color, line style, and faceting to show group changes over time for a continuous variable across categorical levels."
  },
  {
    "objectID": "grp_line_graphs.html#set-up",
    "href": "grp_line_graphs.html#set-up",
    "title": "Grouped line graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grp_line_graphs.html#grammar",
    "href": "grp_line_graphs.html#grammar",
    "title": "Grouped line graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grp_line_graphs.html#more-info",
    "href": "grp_line_graphs.html#more-info",
    "title": "Grouped line graphs",
    "section": "More info",
    "text": "More info\nLine graphs are great for displaying relationships across variables with multiple groups (or levels). We can also use facets for multiple comparisons (i.e., small multiples).\n\nGroupsLine StylesLabelsFacets\n\n\n\nDATA:\n\n\nIn the previous graph, we can see the number of births begins to decline around 2007 or 2008. We’ll create another summarized dataset from the usbirth_2010_2014 data, but this time we restrict the observations to only births in between 2008 and 2009, group on yr_qtr and day_of_week, and get the average number of births (as avg_births).\n\n\n\n\nCode\navg_births_dow_qtr &lt;- usbirth_1994_2014 |&gt;\n    dplyr::filter(year &gt;= 2008 & year &lt;= 2009) |&gt; \n    dplyr::group_by(yr_qtr, day_of_week) |&gt;\n    dplyr::summarise(avg_births = mean(births, na.rm = TRUE)) |&gt;\n    dplyr::ungroup() \ndplyr::glimpse(avg_births_dow_qtr)\n#&gt; Rows: 56\n#&gt; Columns: 3\n#&gt; $ yr_qtr      &lt;ord&gt; 2008/01, 2008/01, 2008/01, 2008/01, 20…\n#&gt; $ day_of_week &lt;ord&gt; Sun, Mon, Tues, Wed, Thurs, Fri, Sat, …\n#&gt; $ avg_births  &lt;dbl&gt; 7497.231, 12464.385, 13099.692, 13139.…\n\n\n\n\nGROUPS:\n\n\nNow when we create our line graph, we will have a categorical variable with seven levels (day_of_week):\n\nCreate subtitle using paste0() to ensure it’s accurate if/when the underlying data is updated.\n\nmove the legend to the top of the graph using theme(legend.position = \"top\") (to improve readability).\n\n\n\n\n\nCode\n# here we create the labels (with the subtitle updating with the data)\nlabs_line_graph_grp &lt;- labs(title = \"Average US births\", \n                        subtitle = paste0(\"Between \",\n                                    min(avg_births_dow_qtr$yr_qtr), \n                                    \" and \",\n                                    max(avg_births_dow_qtr$yr_qtr)),\n                        y = \"Average births\", \n                        x = \"Year/Quarter\",  \n                        color = \"Day of Week\")\n\n\n\n\n\n\n\n\n\nCode\n# Build layer with yr_qtr and day_of_week\nggp2_line_grp &lt;- ggplot(data = avg_births_dow_qtr, \n                   mapping = aes(x = yr_qtr, \n                                 y = avg_births, \n                                 group = day_of_week)) + \n        geom_line(aes(color = day_of_week)) \n# move legend\nggp2_line_grp + \n    labs_line_graph_grp + \n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can make it easier to distinguish between lines in our graph by adjusting the line style (linetype and linewidth), or by changing overall opacity (alpha).\nWe’ll work through some examples below using another subset from usbirth_1994_2014.\n\n\nDATA:\n\n\n\n\n\n\n\nCode\navg_births_dow_mnth &lt;- usbirth_1994_2014 |&gt;\n    dplyr::filter(year &gt;= 2008 & year &lt; 2010) |&gt;\n    dplyr::group_by(yr_mnth, day_of_week) |&gt;\n    dplyr::summarise(avg_births = mean(births, na.rm = TRUE)) |&gt;\n    dplyr::ungroup()\ndplyr::glimpse(avg_births_dow_mnth)\n#&gt; Rows: 168\n#&gt; Columns: 3\n#&gt; $ yr_mnth     &lt;date&gt; 2008-01-01, 2008-01-01, 2008-01-01, 2…\n#&gt; $ day_of_week &lt;ord&gt; Sun, Mon, Tues, Wed, Thurs, Fri, Sat, …\n#&gt; $ avg_births  &lt;dbl&gt; 7535.25, 12344.00, 12280.60, 12925.00,…\n\n\n\n\n\n\n\n\n\nCode\nlabs_line_styles &lt;- labs(\n    title = \"Average US births\",\n    subtitle = paste0(\n        \"Between \",\n        min(avg_births_dow_mnth$yr_mnth),\n        \" and \",\n        max(avg_births_dow_mnth$yr_mnth)\n    ),\n    y = \"Average births\",\n    x = \"Year-Month\",\n    color = \"Day of Week\"\n)\n\n\n\n\n\n\n\nalpha & linewidth:\n\n\nColor palettes are a excellent too for highlighting or emphasizing certain lines over others.\nWe’ll start by creating a line graph layer for Monday (\"Mon\"), Thursday (\"Thurs\"), and Friday (\"Fri\") adjusting the opacity with alpha.\n\n\n\n\nCode\nggp2_line_mon_thur_fri &lt;-\n    ggplot(data = dplyr::filter(avg_births_dow_mnth,\n        day_of_week %in% c(\"Mon\", \"Thurs\", \"Fri\"))) +\n    geom_line(\n        aes(x = yr_mnth,\n            y = avg_births,\n            group = day_of_week,\n            color = day_of_week),\n        alpha = 1 / 4,\n        linewidth = 0.85)\n# layer 1\nggp2_line_mon_thur_fri +\n    labs_line_styles +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nlinetype:\n\n\nThen we’ll change the linetype of Saturday and Sunday to \"longdash' (and make this somewhat transparent with a slightly higher alpha).\n\n\n\n\nCode\nggp2_line_sat_sun &lt;- ggp2_line_mon_thur_fri +\n    geom_line(data = dplyr::filter(avg_births_dow_mnth,\n            day_of_week %in% c(\"Sat\", \"Sun\")),\n        aes(x = yr_mnth,\n            y = avg_births,\n            group = day_of_week,\n            color = day_of_week),\n        alpha = 1 / 2,\n        linewidth = 0.75,\n        linetype = \"longdash\")\n# layers 1 & 2\nggp2_line_sat_sun +\n    labs_line_styles +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nColor palettes:\n\n\nAdd geom_line() for Wednesday and Tuesday, but change the color pallete with paletteer and ggthemes.\nWe also manually set the legend order by supplying the original factor levels to the breaks argument.\n\n\n\n\nCode\nlibrary(paletteer)\nlibrary(ggthemes)\n# original factor levels\nlev_order &lt;- levels(avg_births_dow_mnth$day_of_week)\n# layer 3\nggp2_line_pal_d &lt;- ggp2_line_sat_sun +\n    # add line\n    geom_line(data = dplyr::filter(avg_births_dow_mnth,\n            day_of_week %in% c(\"Wed\", \"Tues\")),\n        aes(x = yr_mnth,\n            y = avg_births,\n            group = day_of_week,\n            color = day_of_week),\n        linewidth = 1.25) +\n    # add palette\n    ggplot2::scale_color_manual(\n        breaks = lev_order,\n        # original factor levels\n        values = paletteer::paletteer_d(palette = \"ggthemes::Color_Blind\",\n            n = 7))\n# three layers\nggp2_line_pal_d +\n    # labels\n    labs_line_styles +\n    # legend position\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nChanging the look of the lines is a great way to highlight or emphasize some lines over others.\n\n\n\n\nLABELS:\n\n\nIn the previous graph, we can see the number of average births reaches it’s peak in 2008 or 2009, so we’ll use labels to display the max births and max average births.\nTo accomplish this, we’re going to create two small tables of labels, label_max_dow and label_max_avg_dow, that we’ll use to label the maximum values.\nThey will each have 7 rows (one for each day of the week) and a label variable (lbl) which we can use with geom_label().\n\n\n\n\nCode\nlabel_max_dow &lt;- usbirth_1994_2014 |&gt;\n    dplyr::group_by(day_of_week) |&gt;\n    dplyr::summarise(max_births = max(births, na.rm = TRUE)) |&gt;\n    dplyr::ungroup() |&gt;\n    dplyr::arrange(desc(max_births)) |&gt;\n    dplyr::inner_join(y = usbirth_1994_2014,\n        by = c(\"max_births\" = \"births\", \"day_of_week\")) |&gt;\n    dplyr::mutate(lbl = paste0(day_of_week,\n        \" (\",\n        date,\n        \" )\",\n        \", max births = \",\n        max_births)) |&gt;\n    dplyr::select(day_of_week, yr_mnth, max_births, lbl)\n\ndplyr::arrange(label_max_dow, desc(max_births)) |&gt;\n    dplyr::slice(1:2)\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nCode\nlabel_max_avg_dow &lt;- avg_births_dow_mnth |&gt;\n    # group by mon-sun\n    dplyr::group_by(day_of_week) |&gt;\n    # get max avg\n    dplyr::summarise(max_avg_births = max(avg_births, na.rm = TRUE)) |&gt;\n    # ungroup\n    dplyr::ungroup() |&gt;\n    # join back to table\n    dplyr::inner_join(y = avg_births_dow_mnth,\n        by = \"day_of_week\") |&gt;\n    # check for max\n    dplyr::mutate(is_max = case_when(\n        avg_births == max_avg_births ~ TRUE,\n        avg_births != max_avg_births ~ FALSE,\n    )) |&gt;\n    # remove non-maxes\n    filter(is_max == TRUE) |&gt;\n    dplyr::mutate(lbl = paste0(day_of_week,\n        \": Max avg births = \",\n        max_avg_births)) |&gt;\n    # reduce\n    select(day_of_week, yr_mnth, max_avg_births, lbl)\ndplyr::arrange(label_max_avg_dow, desc(max_avg_births)) |&gt;\n    dplyr::slice(1:2)\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\nNow that we have label tables for each metric, we can filter them to the days we want to label.\nWe’ll use filter() to get the maximum values for \"Wed\" (in label_max_wed_dow and label_max_avg_wed_dow):\n\n\n\n\nCode\n# get wed\nlabel_max_wed_dow &lt;- label_max_dow |&gt;\n    filter(day_of_week == \"Wed\")\nlabel_max_wed_dow\nlabel_max_avg_wed_dow &lt;- label_max_avg_dow |&gt;\n    filter(day_of_week == \"Wed\")\nlabel_max_avg_wed_dow\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\nAdd geom_point() and geom_label() for Wednesday.\n\n\n\n\nCode\n# point for max births/day\nggp2_line_wed_max_births_pnts &lt;- geom_point(\n    data = label_max_wed_dow,\n    aes(x = yr_mnth,\n        y = max_births,\n        color = day_of_week),\n    size = 2.5,\n    show.legend = FALSE)\n\nggp2_line_wed_max_avg_births_pnts &lt;-\n    geom_point(\n        data = label_max_avg_wed_dow,\n        aes(x = yr_mnth,\n            y = max_avg_births,\n            color = day_of_week),\n        size = 2.5,\n        alpha = 1/2,\n        show.legend = FALSE)\n\nggp2_line_wed_max_births_lbl &lt;- geom_label(\n    data = label_max_wed_dow,\n    aes(x = yr_mnth,\n        y = max_births,\n        label = lbl,\n        color = day_of_week),\n    fill = \"#ffffff\",\n    nudge_y = -480,\n    nudge_x = 25,\n    size = 1.3,\n    show.legend = FALSE)\n\nggp2_line_wed_max_avg_births_lbl &lt;-\n    geom_label(data = label_max_avg_wed_dow,\n        aes(x = yr_mnth,\n            y = max_avg_births,\n            label = lbl,\n            color = day_of_week),\n        fill = \"#ffffff\",\n        nudge_y = 145,\n        nudge_x = 85,\n        size = 1.3,\n        show.legend = FALSE)\n\nggp2_line_pal_d + \n    ggp2_line_wed_max_births_pnts + \n    ggp2_line_wed_max_avg_births_pnts +\n    ggp2_line_wed_max_births_lbl + \n    ggp2_line_wed_max_avg_births_lbl + \n    # add labels\n    labs_line_styles +\n    # move legend to top\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nWe’ll use filter() to get the maximum values for \"Tues\" (in label_max_tues_dow and label_max_avg_tues_dow):\n\n\n\n\nCode\n# point for max births/day\n# get tues\nlabel_max_tues_dow &lt;- label_max_dow |&gt; \n    filter(day_of_week == \"Tues\")\nlabel_max_tues_dow\nlabel_max_avg_tues_dow &lt;- label_max_avg_dow |&gt; \n    filter(day_of_week == \"Tues\")\nlabel_max_avg_tues_dow\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\nAdd geom_point() and geom_label() for Tuesday.\n\n\n\n\nCode\n# point for max births/day\nggp2_line_tues_max_births_pnts &lt;-\n    geom_point(data = label_max_tues_dow,\n        aes(x = yr_mnth,\n            y = max_births,\n            color = day_of_week),\n        size = 2.5,\n        show.legend = FALSE)\n\nggp2_line_tues_max_avg_births_pnts &lt;-\n    geom_point(\n        data = label_max_avg_tues_dow,\n        aes(x = yr_mnth,\n            y = max_avg_births,\n            color = day_of_week),\n        size = 2.5,\n        alpha = 1/2,\n        show.legend = FALSE)\n\nggp2_line_tues_max_births_lbl &lt;-\n    geom_label(data = label_max_tues_dow,\n        aes(x = yr_mnth,\n            y = max_births,\n            label = lbl,\n            color = day_of_week),\n        fill = \"#ffffff\",\n        nudge_y = -480,\n        nudge_x = 50,\n        size = 1.3,\n        show.legend = FALSE)\n\nggp2_line_tues_max_avg_births_lbl &lt;-\n    geom_label(data = label_max_avg_tues_dow,\n        aes(x = yr_mnth,\n            y = max_avg_births,\n            label = lbl,\n            color = day_of_week),\n        fill = \"#ffffff\",\n        nudge_y = 300,\n        nudge_x = -80,\n        size = 1.3,\n        show.legend = FALSE)\n\n\nggp2_line_pal_d + \n    # wednesday layers \n    ggp2_line_wed_max_births_pnts + \n    ggp2_line_wed_max_avg_births_pnts +\n    ggp2_line_wed_max_births_lbl + \n    ggp2_line_wed_max_avg_births_lbl +\n    # tuesday layers \n    ggp2_line_tues_max_births_pnts + \n    ggp2_line_tues_max_avg_births_pnts +\n    ggp2_line_tues_max_births_lbl + \n    ggp2_line_tues_max_avg_births_lbl + \n    # add labels\n    labs_line_styles +\n    # move legend to top\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nDATA:\n\n\nFinally, we can use facets to view each of the line graphs seperately (or small multiples).\nWe’ll create a dataset with the dates limited to births between 2008-07-01 and 2010-01-01, and calculate the median births, grouped by date, day_category, and day_of_week and store it as med_births_dcat_dow_mnth.\n\n\n\n\nCode\nmed_births_dcat_dow_mnth &lt;- usbirth_1994_2014 |&gt;\n    dplyr::filter(date &gt;= lubridate::as_date(\"2008-07-01\") &\n            date &lt; lubridate::as_date(\"2010-01-01\")) |&gt;\n    dplyr::group_by(date, day_category, day_of_week) |&gt;\n    dplyr::summarise(med_births = median(births, na.rm = TRUE)) |&gt;\n    dplyr::ungroup()\ndplyr::glimpse(med_births_dcat_dow_mnth)\n#&gt; Rows: 549\n#&gt; Columns: 4\n#&gt; $ date         &lt;date&gt; 2008-07-01, 2008-07-02, 2008-07-03, …\n#&gt; $ day_category &lt;chr&gt; \"Weekday\", \"Weekday\", \"Weekday\", \"Wee…\n#&gt; $ day_of_week  &lt;ord&gt; Tues, Wed, Thurs, Fri, Sat, Sun, Mon,…\n#&gt; $ med_births   &lt;int&gt; 14350, 14189, 14182, 9449, 8061, 7725…\n\n\n\n\nFACETS:\n\n\nUsing facet_wrap() with a single categorical variable (. ~ var) will create a plot for each discrete level, while facet_grid() will create a level-by-level grid (specified as var ~ var).\n\n\n\n\nCode\n# labels\nlabs_line_graph_facet_wrap &lt;- labs(\n    title = \"Median US births\",\n    subtitle = paste0(\n        \"Between \",\n        min(med_births_dcat_dow_mnth$date),\n        \" and \",\n        max(med_births_dcat_dow_mnth$date)\n    ),\n    y = \"Median births\",\n    x = \"Date\",\n    color = \"Day of Week\"\n)\n# layer\nggp2_line_facet_wrap &lt;- ggplot(data = med_births_dcat_dow_mnth,\n    mapping = aes(x = date,\n        y = med_births,\n        group = day_of_week)) +\n    geom_line(aes(color = day_of_week)) +\n    scale_color_manual(values = c(\n        \"#30123B\", \"#4485F6\", \"#1AE4B6\",\n        \"#A1FB3E\", \"#FABA39\", \"#E3460B\", \"#7A0403\"\n    )) +\n    scale_y_continuous(\n        breaks = c(4000, 8000, 12000, 16000),\n        labels = c('4000', '8000', '12000', '16000')\n    ) +\n    scale_x_date(date_breaks = \"1 year\",\n        date_labels = c(\"2008\", \"2009\", \"2010\")) +\n    facet_wrap(day_of_week ~ ., shrink = TRUE)\n\nggp2_line_facet_wrap +\n    labs_line_graph_facet_wrap +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nIt’s always a good idea to check the x and y axis text when using facets. I’ve adjusted the x and y axes above using scale_y_continuous() and scale_x_date() before adding facet_wrap()\n\n\n\n\nCode\n# labels\nlabs_line_graph_facet_grid &lt;- labs(\n    title = \"Median US births\",\n    subtitle = paste0(\n        \"Between \",\n        min(med_births_dcat_dow_mnth$date),\n        \" and \",\n        max(med_births_dcat_dow_mnth$date)\n    ),\n    y = \"Median births\",\n    x = \"Date\",\n    color = \"Day of Week\"\n)\n# layer\nggp2_line_facet_grid &lt;- ggplot(data = med_births_dcat_dow_mnth,\n    mapping = aes(x = date,\n        y = med_births,\n        group = day_of_week)) +\n    geom_line(aes(color = day_of_week)) +\n    scale_color_manual(values = c(\n        \"#30123B\", \"#4485F6\", \"#1AE4B6\",\n        \"#A1FB3E\", \"#FABA39\", \"#E3460B\", \"#7A0403\"\n    )) +\n    scale_y_continuous(\n        breaks = c(4000, 8000, 12000, 16000),\n        labels = c('4000', '8000', '12000', '16000')\n    ) +\n    scale_x_date(date_breaks = \"1 year\",\n        date_labels = c(\"2008\", \"2009\", \"2010\")) +\n    facet_grid(day_of_week ~ day_category,\n        shrink = TRUE)\n\nggp2_line_facet_grid +\n    labs_line_graph_facet_grid\n\n\n\n\n\n\n\n\n\n\n\nThe colors have been manually, using scale_color_manual() and passing seven color hex codes to the values argument."
  },
  {
    "objectID": "bump_charts.html#description",
    "href": "bump_charts.html#description",
    "title": "Bump charts",
    "section": "Description",
    "text": "Description\nBump charts show how numerical (ranked) values change over time for different categories (or groups). Differences are represented with connecting lines (along the y axis) that cover the full timescale (along the x axis).\nWe can build bump charts in ggplot2 with the ggbump package:"
  },
  {
    "objectID": "bump_charts.html#set-up",
    "href": "bump_charts.html#set-up",
    "title": "Bump charts",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "bump_charts.html#grammar",
    "href": "bump_charts.html#grammar",
    "title": "Bump charts",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "slope_graphs.html#description",
    "href": "slope_graphs.html#description",
    "title": "Slope graphs",
    "section": "Description",
    "text": "Description\nSlope graphs show changes in a numeric value (displayed on the y axis) typically over two points in time (along the x axis). The values for each group or unit of measurement are connected by lines, and any differences between the two time points are represented by the slope of the lines (hence the name, ‘slope chart’).\nWe can build slope graphs in ggplot2 using the geom_line() and geom_point() functions."
  },
  {
    "objectID": "slope_graphs.html#set-up",
    "href": "slope_graphs.html#set-up",
    "title": "Slope graphs",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "slope_graphs.html#grammar",
    "href": "slope_graphs.html#grammar",
    "title": "Slope graphs",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "slope_graphs.html#more-info",
    "href": "slope_graphs.html#more-info",
    "title": "Slope graphs",
    "section": "More info",
    "text": "More info\nWe can also use faceting with slope graphs to add a third categorical variable."
  },
  {
    "objectID": "stream_plots.html#description",
    "href": "stream_plots.html#description",
    "title": "Stream plots",
    "section": "Description",
    "text": "Description\nStream graphs display how a numerical variable (typically on the y axis) changes over time (on the x axis) across levels of a categorical variable. These graphs are handy if the numerical value varies wildly (or isn’t always present) over the time measurement.\nCategorical groups are differentiated by color layers, with the area of the layer representing the change in y value. In ggplot2, we can create stream graphs using ggstream."
  },
  {
    "objectID": "stream_plots.html#set-up",
    "href": "stream_plots.html#set-up",
    "title": "Stream plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "stream_plots.html#grammar",
    "href": "stream_plots.html#grammar",
    "title": "Stream plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "stream_plots.html#more-info",
    "href": "stream_plots.html#more-info",
    "title": "Stream plots",
    "section": "More info",
    "text": "More info\nThe ggstream package has multiple arguments for adjusting the shape and look of the categorical levels (and text labels).\n\nTypeSorting\n\n\n\nTYPE:\n\n\nMap mpaa to fill (wrapped in forcats::fct_rev())\nWe can adjust the look of the graph by setting the type argument in geom_stream()\n\ntype: change type from \"mirror\" (the default) to \"proportional\"\n\nAdjust colors:\n\nscale_fill_manual(): Add colors as a named vector to values\n\nFinally, add the fill to the labels and move the legend with theme(legend.position = \"bottom\")\n\n\n\n\nCode\nggp2_stream_prp &lt;- ggplot(data = movies_stream, \n    mapping = aes(x = year, \n                  y = avg_budget, \n                  fill = forcats::fct_rev(mpaa))) + \n    ggstream::geom_stream(type = \"proportional\") + \n    scale_y_continuous(labels = scales::percent) + \n  scale_fill_manual(\n      values = c(\"PG-13\" = \"#0bd3d3\", \n                 \"PG\" = \"#f890e7\", \n                 \"R\" = \"#282b2d\", \n                 \"NC-17\" = \"#772953\"))\nggp2_stream_prp + \n    labs_stream + \n    labs(fill = \"mpaa\") + \n    theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nSORTING:\n\n\nTo change how the categorical areas are sorted, adjust the sorting argument to either \"none\", \"onset\", or \"inside_out\"\n\nsorting: set the sorting method to \"inside_out\" in both ggstream::geom_stream() and ggstream::geom_stream_label()\n\ntype: change the type to \"ridge\" in both ggstream::geom_stream() and ggstream::geom_stream_label()\n\nWe can also add text labels using ggstream::geom_stream_label():\n\nMap mpaa (wrapped in forcats::fct_rev()) to label globally\n\nInside ggstream::geom_stream_label():\n\nset color to white (\"#ffffff\") and the size to 2.7\n\nRemove the legend with show.legend = FALSE\n\n\nColors:\n\nUse scale_colour_manual() and scale_fill_manual() to manually set the values using a named vector\n\nChange the y axis to US dollars using scale_y_continuous() and scales::dollar\nFinally, add the fill to the labels and move the legend with theme(legend.position = \"bottom\")\n\n\n\n\nCode\nggp2_stream_srt &lt;- ggplot(data = movies_stream, \n    mapping = aes(x = year, \n                  y = avg_budget, \n                  fill = fct_rev(mpaa),\n                  label = fct_rev(mpaa))) + \n    ggstream::geom_stream(\n        type = \"ridge\", \n        sorting = \"inside_out\") + \n    ggstream::geom_stream_label(\n        type = \"ridge\", \n        sorting = \"inside_out\", \n        color = \"#ffffff\", \n        size = 2.7,\n        show.legend = FALSE) +\n    scale_colour_manual(\n      values = c(\"PG-13\" = \"#0bd3d3\", \n                 \"PG\" = \"#f890e7\", \n                 \"R\" = \"#282b2d\", \n                 \"NC-17\" = \"#772953\")) +\n    scale_fill_manual(\n      values = c(\"PG-13\" = \"#0bd3d3\", \n                 \"PG\" = \"#f890e7\", \n                 \"R\" = \"#282b2d\", \n                 \"NC-17\" = \"#772953\")) + \n    scale_y_continuous(labels = scales::dollar) \n    \nggp2_stream_srt + \n    labs_stream + \n    labs(fill = \"mpaa\") + \n    theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "alluvial_charts.html#description",
    "href": "alluvial_charts.html#description",
    "title": "Alluvial charts",
    "section": "Description",
    "text": "Description\nAn alluvial graph displays the changes in composition or flow over time or across multiple categories.\nWe can build alluvial charts in ggplot2 with the ggalluvial package:.\nSee also: parallel sets"
  },
  {
    "objectID": "alluvial_charts.html#set-up",
    "href": "alluvial_charts.html#set-up",
    "title": "Alluvial charts",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "alluvial_charts.html#grammar",
    "href": "alluvial_charts.html#grammar",
    "title": "Alluvial charts",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "alluvial_charts.html#more-info",
    "href": "alluvial_charts.html#more-info",
    "title": "Alluvial charts",
    "section": "More info",
    "text": "More info\nThe ggalluvial package can also help reshape data with the to_lodes_form() function.\n\nto_lodes_form()geom_flow()legend.position\n\n\n\nto_lodes_form():\n\n\nBelow we create peng_lodes from the penguins dataset using the to_lodes_form() from the ggalluvial package.\n\n\n\n\nCode\npeng_lodes &lt;- penguins |&gt; \n  dplyr::select(Year = year, Island = island, \n         Species = species, Sex = sex) |&gt; \n  tidyr::drop_na() |&gt; \n  dplyr::count(Year, Island, Species, Sex) |&gt; \n  dplyr::mutate(Year = factor(Year)) |&gt; \n  dplyr::rename(Freqency = n) |&gt; \n  ggalluvial::to_lodes_form(key = \"Measure\", axes = 1:3) \nglimpse(peng_lodes)\n#&gt; Rows: 90\n#&gt; Columns: 5\n#&gt; $ Sex      &lt;fct&gt; female, male, female, male, female, male,…\n#&gt; $ Freqency &lt;int&gt; 5, 5, 16, 17, 9, 10, 13, 13, 8, 7, 9, 9, …\n#&gt; $ alluvium &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13…\n#&gt; $ Measure  &lt;fct&gt; Year, Year, Year, Year, Year, Year, Year,…\n#&gt; $ stratum  &lt;fct&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007,…\n\n\n\n\nCreate labels with labs()\nMap Measure to x, Frequency to y, stratum to stratum, alluvium to alluvium, and label to stratum.\nAdd the geom_alluvium() and map Sex to fill\nAdd the geom_stratum() and set the width to 0.45\nAdd geom_text() and set stat to \"stratum\"\n\n\n\n\nCode\nlabs_alluvial &lt;- ggtitle(label = \"Palmer Penguins\", \n    subtitle = \"Stratified by year, island and species\")\n\nggp2_alluvial_lf &lt;- ggplot(\n    data = peng_lodes,\n    aes(x = Measure,\n        y = Freqency,\n        stratum = stratum,\n        alluvium = alluvium,\n        label = stratum)) +\n    ggalluvial::geom_alluvium(aes(fill = Sex)) +\n    ggalluvial::geom_stratum(width = 0.45) +\n    geom_text(stat = \"stratum\", size = 2.5)\n\nggp2_alluvial_lf +\n    labs_alluvial +\n    theme_ggp2g(base_size = 13)\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_flow():\n\n\nIf you’d like to arrange the date or time variable across the x, you can use the ggalluvial::geom_flow() with ggalluvial::geom_stratum().\nFirst create peng_alluvial, a subset of palmerpenguins::penguins_raw with all variables turned to factors.\n\n\n\n\nCode\npeng_alluvial &lt;- palmerpenguins::penguins_raw |&gt; \n  janitor::clean_names() |&gt; \n  dplyr::mutate(year = lubridate::year(date_egg),\n         year = factor(year),\n         individual_id = factor(individual_id),\n         island = factor(island)) |&gt; \n  dplyr::select(year, individual_id, island)\ndplyr::glimpse(peng_alluvial)\n#&gt; Rows: 344\n#&gt; Columns: 3\n#&gt; $ year          &lt;fct&gt; 2007, 2007, 2007, 2007, 2007, 2007, …\n#&gt; $ individual_id &lt;fct&gt; N1A1, N1A2, N2A1, N2A2, N3A1, N3A2, …\n#&gt; $ island        &lt;fct&gt; Torgersen, Torgersen, Torgersen, Tor…\n\n\n\n\nCreate labels with labs()\nInitiate graph with data\nMap the year to the x, island to stratum, individual_id to alluvium, island to fill, and island to label.\nAdd scale_fill_brewer(), and set the type to \"qual\" and choose a palette\nAdd the geom_flow(), with stat set to \"alluvium\", lode.guidance set to \"frontback\", and color to \"#A9A9A9\"\nAdd ggalluvial::geom_stratum()\n\n\n\n\nCode\n# labels\nlabs_alluvial &lt;- labs(\n  title = \"Penguin measurements across three years\")\n# add geom_flow() \nggp2_alluvial_flow &lt;- ggplot(data = peng_alluvial,\n  mapping = aes(x = year, stratum = island, \n    alluvium = individual_id, \n    fill = island, label = island)) +\n  scale_fill_brewer(type = \"qual\", palette = \"Pastel2\") +\n  geom_flow(stat = \"alluvium\",\n    lode.guidance = \"frontback\",\n    color = \"#A9A9A9\")\n\nggp2_alluvial_flow\n\n# add geom_stratum()\nggp2_alluvial_stratum &lt;- ggp2_alluvial_flow +\n  geom_stratum() \nggp2_alluvial_stratum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlegend.position:\n\n\nMove legend to bottom with theme(legend.position = \"bottom\")\n\n\n\n\nCode\nggp2_alluvial_stratum + \n  labs_alluvial + \n  theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "instance_chart.html#description",
    "href": "instance_chart.html#description",
    "title": "Instance chart",
    "section": "Description",
    "text": "Description\n\nAn instance chart (or instance graph) displays frequencies (or ‘instances’) of different categorical values over time time.\nThe time dimension is placed on the x and each separate categorical item is placed on the y-axis. The instances are typically represented using the vertical hashes from geom_point() (i.e., shape 124 or the ‘pipe’ \"|\").\nSaturation and color are also used to represent different categorical levels and counts."
  },
  {
    "objectID": "instance_chart.html#set-up",
    "href": "instance_chart.html#set-up",
    "title": "Instance chart",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "instance_chart.html#grammar",
    "href": "instance_chart.html#grammar",
    "title": "Instance chart",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "instance_chart.html#more-info",
    "href": "instance_chart.html#more-info",
    "title": "Instance chart",
    "section": "More info",
    "text": "More info\n\n\nggplot2::cut_interval()\n\n\n\nggplot2::cut_number()\n\n\nSaturationFacets\n\n\n\n\nggplot2::cut_interval():\n\n\nggplot2 has two great functions for splitting numerical variables into intervals or widths. We’re going to create two datasets from babynames::babynames that capture the top names in 1900 and and the top names 2000.\n\n\n\n\nCode\ntop_nms_prop_1900 &lt;- babynames::babynames |&gt;\n  dplyr::filter(year == 1900) |&gt;\n  dplyr::group_by(sex, name) |&gt; \n  dplyr::summarise(max_prop = max(prop)) |&gt; \n  dplyr::slice_max(n = 2, order_by = max_prop) |&gt;\n  dplyr::ungroup()\ntop_nms_prop_1900\ntop_nms_prop_2000 &lt;- babynames::babynames |&gt;\n  dplyr::filter(year == 2000) |&gt;\n  dplyr::group_by(sex, name) |&gt; \n  dplyr::summarise(max_prop = max(prop)) |&gt; \n  dplyr::slice_max(n = 2, order_by = max_prop) |&gt;\n  dplyr::ungroup()\ntop_nms_prop_2000\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n\n\n\n\nThese two tibbles tell us something about the top names over a century. The top names in 1900 have much higher proportions than the top names in 2000s.\nWe’ll get the names from both tibbles and filter babynames::babynames to only these eight names between the years 1900 and 2000.\nWe’ll create a prop_range variable, which splits the prop variable into intervals based on the length argument.\n\n\n\n\nCode\nnms_1900 &lt;- top_nms_prop_1900[[\"name\"]]\nnms_2000 &lt;- top_nms_prop_2000[[\"name\"]]\n\ntop_nms_1900_2000 &lt;- c(nms_1900, nms_2000)\n\npopular_bby_nms_prop &lt;- babynames::babynames |&gt;\n  dplyr::filter(name %in% top_nms_1900_2000 &\n                  year &gt;= 1900 &\n                    year &lt;= 2000) |&gt;\n  dplyr::mutate(\n    # proportion range \n    prop_range = ggplot2::cut_interval(x = prop, \n                                       length = 0.025))\n\n\n\n\n\n\n\nBelow we can see the proportion ranges have been built with the interval notation: \"(a,b]\"\nWe can also see the proportion of names changes considerably between the two groups of names.\n\n\n\n\nCode\nlabs_inst_pop_nms_prop &lt;- labs(\n  title = \"100 years of popular names\",\n  subtitle = \"Most popular names from 1900 and 2000\",\n  caption = \"*based on proportion\",\n  x = \"Year\",\n  y = \"Name\",\n  color = \"Proportion ranges\",\n  alpha = \"Proportion\")\nggp2_inst_pop_nms_prop &lt;- ggplot(data = popular_bby_nms_prop, \n    mapping = aes(x = year, \n                  y = name, \n              color = prop_range)) + \n  geom_point(aes(alpha = prop),\n                shape = 124,\n                size = 2.5) \nggp2_inst_pop_nms_prop + \n  labs_inst_pop_nms_prop \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2::cut_number():\n\n\nTo demonstrate facets, we’ll create two other variables: year_range and group:\n- year_range uses ggplot2::cut_number() to create three groups based on the year, orders the results, and removes the labels. We manually assign the labels to this variable with case_when() and factor()\n- group is a factor variable with two levels: 1900 names and 2000 names\n\n\n\n\nCode\npopular_bby_nms_fct &lt;- popular_bby_nms_prop |&gt;\n  dplyr::mutate(\n    # year range \n    year_range = ggplot2::cut_number(year, \n                                       n = 3, \n                                  labels = FALSE,\n                          ordered_result = TRUE),\n  year_range = case_when(\n    year_range == 1 ~ \"1900 - 1936\",\n    year_range == 2 ~ \"1937 - 1970\",\n    year_range == 3 ~ \"1971 - 2000\"),\n  year_range = factor(year_range,\n    levels = c(\"1900 - 1936\",\n               \"1937 - 1970\",\n               \"1971 - 2000\"),\n    ordered = TRUE),\n    group = case_when(\n      name %in% nms_1900 ~ \"1900 names\",\n      name %in% nms_2000 ~ \"2000 names\",\n      TRUE ~ NA_character_),\n    group = factor(group, \n      levels = c(\"1900 names\", \n                 \"2000 names\")))\n\n\n\n\n\n\n\nBelow we can see the total counts of names in the cross-table of year_range and group:\n\n\n\n\nCode\npopular_bby_nms_fct |&gt; \n  dplyr::count(year_range, group) |&gt; \n  tidyr::pivot_wider(names_from = group, \n    values_from = n)\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\nIn the graph, we’ll create labels using the levels from the year_range variable.\nWe can also change the shape used in geom_point() to the pipe operator (\"|\").\n\n\n\n\nCode\n# create labels from factor levels \nst_lbls &lt;- paste0(\n              levels(popular_bby_nms_fct$year_range),\n            collapse = \", \")\n\nlabs_inst_pop_nms_facet &lt;- labs(\n  title = \"Baby name popularity over time\",\n  subtitle = paste0(\"Time span: \", st_lbls),\n  x = \"Year\",\n  y = \"Name\")\n\nggp2_inst_pop_nms_facet &lt;- ggplot(popular_bby_nms_fct,\n  mapping = aes(x = year,\n                y = name)) +\n  geom_point(aes(alpha = prop, color = name),\n                 shape = \"|\",\n                 size = 3,\n                 show.legend = FALSE) +\n  facet_wrap(year_range ~ group,\n             scales = \"free_y\", \n             ncol = 2)\nggp2_inst_pop_nms_facet +\n  labs_inst_pop_nms_facet"
  },
  {
    "objectID": "relationships.html",
    "href": "relationships.html",
    "title": "RELATIONSHIPS",
    "section": "",
    "text": "This graph is largely complete and just needs final proof reading.\n\n\n\nRelationships: these graphs show how the change of values in variable x affect the values in variable y (and possibly z)?"
  },
  {
    "objectID": "scatter_plot.html#description",
    "href": "scatter_plot.html#description",
    "title": "Scatter plots",
    "section": "Description",
    "text": "Description\nScatter plots are used to display two continuous variables.\nIf one of the continuous variables is assumed to affect the other (i.e., outcome vs. predictor), place the outcome on the y axis and the predictor on the x axis."
  },
  {
    "objectID": "scatter_plot.html#set-up",
    "href": "scatter_plot.html#set-up",
    "title": "Scatter plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "scatter_plot.html#grammar",
    "href": "scatter_plot.html#grammar",
    "title": "Scatter plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grouped_scatter_plots.html#description",
    "href": "grouped_scatter_plots.html#description",
    "title": "Grouped scatter plots",
    "section": "Description",
    "text": "Description\nGrouped scatter-plots display the relationships between two continuous variables across a third categorical variable.\nThe x and y position displays the relationship between the two continuous variables, and color is used to distinguish between the categorical levels."
  },
  {
    "objectID": "grouped_scatter_plots.html#set-up",
    "href": "grouped_scatter_plots.html#set-up",
    "title": "Grouped scatter plots",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grouped_scatter_plots.html#grammar",
    "href": "grouped_scatter_plots.html#grammar",
    "title": "Grouped scatter plots",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "bubble_charts.html#description",
    "href": "bubble_charts.html#description",
    "title": "Bubble charts",
    "section": "Description",
    "text": "Description\nBubble graphs display relationships between three numeric (continuous) variables.\nThe position on the x and y axis illustrates the relationship between the first two variables, and the size of the point (i.e., the bubble) conveys the numeric value of the third."
  },
  {
    "objectID": "bubble_charts.html#set-up",
    "href": "bubble_charts.html#set-up",
    "title": "Bubble charts",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "bubble_charts.html#grammar",
    "href": "bubble_charts.html#grammar",
    "title": "Bubble charts",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grouped_bubble_charts.html#description",
    "href": "grouped_bubble_charts.html#description",
    "title": "Grouped bubble graph",
    "section": "Description",
    "text": "Description\nGrouped bubble graphs use position, color, and size to display the relationships between four variables (three numerical/quantitative, one categorical).\nThe position on the x and y axis captures the relationship between two numerical variables. The size and color of the points display a third numerical variable across the levels of a (fourth) categorical variable."
  },
  {
    "objectID": "grouped_bubble_charts.html#set-up",
    "href": "grouped_bubble_charts.html#set-up",
    "title": "Grouped bubble graph",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "grouped_bubble_charts.html#grammar",
    "href": "grouped_bubble_charts.html#grammar",
    "title": "Grouped bubble graph",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "grouped_bubble_charts.html#more-info",
    "href": "grouped_bubble_charts.html#more-info",
    "title": "Grouped bubble graph",
    "section": "More info",
    "text": "More info\nWe can change the shape of the points for more control of the color and fill.\n\nShapeColor\n\n\n\nSHAPE:\n\n\nInside geom_point(), we can set shape to 21, and color to \"#000000\" to outline the points in black\n\n\n\n\nCode\nggp2_grp_bubble_s21 &lt;- penguins |&gt; \n  ggplot(aes(\n    x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point(\n    aes(size = body_mass_g, fill = species), \n        alpha = 2/3, shape = 21, color = \"#000000\") + \n  scale_size(range = c(.04, 6)) \n\nggp2_grp_bubble_s21 + \n  labs_grp_bubble\n\n\n\n\n\n\n\n\n\n\n\n\n\nCOLOR:\n\n\nInside the aes() of geom_point(), we can set shape to 21, and map color to \"species\" to outline the points in the same colors as fill\n\n\n\n\nCode\nggp2_grp_bubble_s21_color &lt;- penguins |&gt; \n  ggplot(aes(\n    x = bill_length_mm, y = flipper_length_mm)) + \n  geom_point(\n    aes(size = body_mass_g, \n        fill = species, \n        color = species), \n        alpha = 2/3, shape = 21) + \n  scale_size(range = c(.04, 6)) \n\nggp2_grp_bubble_s21_color + \n  labs_grp_bubble"
  },
  {
    "objectID": "parallel_sets.html#description",
    "href": "parallel_sets.html#description",
    "title": "Parallel sets",
    "section": "Description",
    "text": "Description\nParallel sets (also referred to as Sankey diagrams or Alluvial charts) show the counts of categorical variables connected via a two-sided parallel display (or ‘sets’). Parallel sets can also be used to show different states of paired dependent relationships (such as input vs output), or time 1 vs time 2.\nThe height of the connecting bands between the categories on the x axis represent the relative counts for each discrete level (displayed on the y axis). The levels within each variable are represented with color.\nWe can build parallel set diagrams with the ggforce package.\nAlso check out alluvial charts."
  },
  {
    "objectID": "parallel_sets.html#set-up",
    "href": "parallel_sets.html#set-up",
    "title": "Parallel sets",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "parallel_sets.html#grammar",
    "href": "parallel_sets.html#grammar",
    "title": "Parallel sets",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "parallel_sets.html#more-info",
    "href": "parallel_sets.html#more-info",
    "title": "Parallel sets",
    "section": "More info",
    "text": "More info\nIf the categories have long names, you can move the location of the labels outside the set.\n\nLabeling sets\n\n\n\nLABELS:\n\n\nIf the categories have long names, use the angle, nudge_x/nudge_y and hjust/vjust in geom_parallel_sets_labels() to adjust the size, location, and color of the labels.\nManually setting the limits of the x axis in scale_x_continuous() will also give more room for the labels.\n\n\n\n\nCode\nggp2_psets_axes + \n  geom_parallel_sets_labels(\n      size = 3.2, \n      colour = '#000000',\n      angle = 0, \n      nudge_x = 0.1, \n      hjust = 0) + \n  scale_x_continuous(\n        limits = c(0.9, 3.2),\n        breaks = c(1, 2, 3), \n        labels = c(\"Island\", \"Species\", \"Sex\")) + \n  theme(axis.title.x = element_blank()) + \n    labs_psets"
  },
  {
    "objectID": "density_contours.html#description",
    "href": "density_contours.html#description",
    "title": "Density contours",
    "section": "Description",
    "text": "Description\nDensity contours (or 2-D density plots) are helpful for displaying differences in values between two numeric (continuous) variables.\nIn topographical maps, contour lines are drawn around areas of equal elevation above sea-level. In density contours, the contour lines are drawn around the areas our data occupy (essentially replacing sea-level as ‘an area without any x or y values.’)\nSpecifically, the contour lines outline areas on the graph with differing point densities, and semi-transparent colors (gradient) can be added to further highlight the separate regions."
  },
  {
    "objectID": "density_contours.html#set-up",
    "href": "density_contours.html#set-up",
    "title": "Density contours",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "density_contours.html#grammar",
    "href": "density_contours.html#grammar",
    "title": "Density contours",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "density_contours.html#more-info",
    "href": "density_contours.html#more-info",
    "title": "Density contours",
    "section": "More info",
    "text": "More info\nWe’re going to break down how to create the density contour layer-by-layer using the stat_density_2d() function (which allows us to access some of the inner-workings of geom_density_2d())\n\nBaseStatFillPoints\n\n\n\nBASE:\n\n\nCreate a new set of labels\nInitialize the graph with ggplot() and provide data\nBuild a base layer:\n\nMap bill_length_mm to x and flipper_length_mm to y\nExpand the x and y values with expand_limits() (using the values we created above)\n\n\n\n\n\nCode\nlabs_sdens_2d &lt;- labs(\n  title = \"Bill Length vs. Flipper Length\",\n  x = \"Bill Length (mm)\",\n  y = \"Flipper length (mm)\",\n  color = \"Species\"\n)\n# base\nbase_sdens_2d &lt;- ggplot(\n  data = peng_dnsty_2d,\n  mapping = aes(\n    x = bill_length_mm,\n    y = flipper_length_mm\n  )\n) +\n  expand_limits(\n    x = c(x_min, x_max),\n    y = c(y_min, y_max)\n  )\nbase_sdens_2d +\n  labs_sdens_2d\n\n\n\n\n\n\n\n\n\n\n\n\n\nSTAT:\n\n\nAdd the stat_density_2d() layer:\n\nInside aes(), use after_stat() to map level to fill (from Help, “Evaluation after stat transformation will have access to the variables calculated by the stat, not the original mapped values.”)\nSet the geom to \"polygon\"\nChange the color to black (#000000)\nadjust the linewidth to 0.35\n\n\n\n\n\nCode\nstat_sdens_2d &lt;- base_sdens_2d +\n  stat_density_2d(\n    aes(fill = after_stat(level)),\n    geom = \"polygon\",\n    color = \"#000000\",\n    linewidth = 0.35\n  )\nstat_sdens_2d +\n  labs_sdens_2d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFILL:\n\n\nWhere did levels come from?\nYou probably noticed the stat_density_2d() produced a legend with level, and a series of values for the color gradient. These numbers are difficult to interpret directly, but you can think of them as ‘elevation changes’ in point density. Read more here on SO.\n\n\nNow that we have a color gradient for our contour lines, we can adjust it’s the range of colors using scale_fill_gradient()\n\nlow is the color for the low values of level\n\nhigh is the color for the high values of level\n\nguide let’s us control the legend\n\nWe’ll set these to white (\"#ffffff\") and dark gray (\"#404040\")\n\n\n\n\nCode\nfill_sdens_2d &lt;- stat_sdens_2d +\n  scale_fill_gradient(\n    low = \"#ffffff\",\n    high = \"#404040\",\n    guide = \"legend\"\n  )\nfill_sdens_2d +\n  labs_sdens_2d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPOINTS:\n\n\nThe dark areas in the contour lines are the areas with higher value density, but why don’t we test that by adding some data points?\nAdd a geom_point() layer\n\nInside aes(), map species to color (this will tell us if the three dark areas represent differences in the three species in the dataset)\nset size to 2\nChange the alpha to 2/3\n\n\n\n\n\nCode\n# geom_point()\npnts_sdens_2d &lt;- fill_sdens_2d +\n  geom_point(aes(color = species),\n    size = 2,\n    alpha = 2 / 3\n  )\n# final\npnts_sdens_2d +\n  labs_sdens_2d"
  },
  {
    "objectID": "density_contours.html#even-more-info",
    "href": "density_contours.html#even-more-info",
    "title": "Density contours",
    "section": "Even more info",
    "text": "Even more info\nIn the previous plot, we used the species variable in the geom_point() layer to identify the points using color. In the section below, we’ll show more methods of displaying groups with density contour lines.\n\nGroupsFacetsFillLines\n\n\n\nGROUPS:\n\n\nRe-create the labels\nInitialize the graph with ggplot() and provide data\nBuild a geom_density_2d() layer:\n\nMap bill_length_mm to x and flipper_length_mm to y\nExpand the limits using our adjusted min/max x and y values\nAdd the geom_density_2d(), mapping species to color\n\nBuild the geom_point() layer:\n\nMap species to color\nset the alpha and remove the legend\n\n\n\n\n\nCode\nlabs_dnsty_2d_grp &lt;- labs(\n  title = \"Bill Length vs. Flipper Length\",\n  x = \"Bill Length (mm)\",\n  y = \"Flipper length (mm)\",\n  color = \"Species\"\n)\n\nggp2_dnsty_2d_grp &lt;- ggplot(\n  data = peng_dnsty_2d,\n  mapping = aes(\n    x = bill_length_mm,\n    y = flipper_length_mm\n  )\n) +\n  expand_limits(\n    x = c(x_min, x_max),\n    y = c(y_min, y_max)\n  ) +\n  geom_density_2d(aes(color = species))\n\n\nggp2_dnsty_2d_pnts &lt;- ggp2_dnsty_2d_grp +\n  geom_point(aes(color = species),\n    alpha = 2 / 3,\n    show.legend = FALSE\n  )\n\nggp2_dnsty_2d_pnts +\n  labs_dnsty_2d_grp\n\n\n\n\n\n\n\n\n\n\n\n\n\nFACETING:\n\n\nRe-create the labels\nInitialize the graph with ggplot() and provide data\nBuild the base/limits:\n\nMap bill_length_mm to x and flipper_length_mm to y\nExpand the limits using our adjusted min/max x and y values\n\nBuild the geom_density_2d_filled() layer:\n\nAdd the geom_density_2d_filled(), setting linewidth to 0.30 and contour_var to \"ndensity\"\n\nAdd the scale_discrete_manual():\n\nset aesthetics to \"fill\"\nProvide a set of color values (this plot needed 10 values, and I grabbed them all from color-hex.\n\nFacet:\n\nAdd facet_wrap(), and place species in the vars()\n\n\n\n\n\nCode\nlabs_dnsty_2d_facet &lt;- labs(\n  title = \"Bill Length vs. Flipper Length\",\n  subtitle = \"By Species\",\n  x = \"Bill Length (mm)\",\n  y = \"Flipper length (mm)\"\n)\nggp2_dnsty_2d_facet &lt;- ggplot(\n  data = peng_dnsty_2d,\n  mapping = aes(\n    x = bill_length_mm,\n    y = flipper_length_mm\n  )\n) +\n  expand_limits(\n    x = c(x_min, x_max),\n    y = c(y_min, y_max)\n  ) +\n  geom_density_2d_filled(\n    linewidth = 0.30,\n    contour_var = \"ndensity\"\n  ) +\n  scale_discrete_manual(\n    aesthetics = \"fill\",\n    values = c(\n      \"#18507a\", \"#2986cc\", \"#3e92d1\", \"#539ed6\", \"#69aadb\",\n      \"#7eb6e0\", \"#a9ceea\", \"#bedaef\", \"#d4e6f4\", \"#e9f2f9\"\n    )\n  ) +\n  facet_wrap(vars(species))\n\nggp2_dnsty_2d_facet +\n  labs_dnsty_2d_facet\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFill:\n\n\nIn the previous section, we defined the color values used in geom_density_2d_filled() with scale_discrete_manual(). Below we give an example using the default colors:\n\n\nRe-create the labels\nInitialize the graph with ggplot() and provide data\nBuild the base/limits:\n\nMap bill_length_mm to x and flipper_length_mm to y\nExpand the limits using our adjusted min/max x and y values\n\nAdd the geom_density_2d() layer\nAdd the geom_density_2d_filled(), setting alpha to 0.8\n\n\n\n\nCode\nlabs_dnsty_2d &lt;- labs(\n  title = \"Bill Length vs. Flipper Length\",\n  x = \"Bill Length (mm)\",\n  y = \"Flipper length (mm)\"\n)\n\nggp2_dnsty_2d &lt;- ggplot(\n  data = peng_dnsty_2d,\n  mapping = aes(\n    x = bill_length_mm,\n    y = flipper_length_mm\n  )\n) +\n  # use our stored values\n  expand_limits(\n    x = c(x_min, x_max),\n    y = c(y_min, y_max)\n  ) +\n  geom_density_2d()\n\nggp2_dnsty_2d_fill &lt;- ggp2_dnsty_2d +\n  geom_density_2d_filled(alpha = 0.8)\n\nggp2_dnsty_2d_fill +\n  labs_dnsty_2d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLINES:\n\n\nWe can also outline the contours by adding color to the lines using another geom_density_2d() layer:\n\nset linewidth to 0.30\nset color to \"#ffffff\"\n\n\n\n\n\nCode\nggp2_dnsty_2d_fill_lns &lt;- ggp2_dnsty_2d_fill +\n  geom_density_2d(\n    linewidth = 0.30,\n    color = \"#ffffff\"\n  )\nggp2_dnsty_2d_fill_lns +\n  labs_dnsty_2d"
  },
  {
    "objectID": "bins_2d.html#description",
    "href": "bins_2d.html#description",
    "title": "2D histograms",
    "section": "Description",
    "text": "Description\nStandard histograms separate a variable’s values into discrete groups, or ‘bins,’ which are arranged in increasing order across the x axis. The y axis displays the frequency (or count) of values within each bin.\nVertical bars capture the variable’s distribution using the height of the bar to represent the number of values per ‘bin’, and the number of bars corresponds with the bin value (or ‘bin-width’).\nWhen we extend this display to two numerical/quantitative variables, the bins are used to divide the total graph area into a grid, and color is used to display the variation in frequency (or count) of both variable values that fall within each intersecting square."
  },
  {
    "objectID": "bins_2d.html#set-up",
    "href": "bins_2d.html#set-up",
    "title": "2D histograms",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "bins_2d.html#grammar",
    "href": "bins_2d.html#grammar",
    "title": "2D histograms",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "bins_2d.html#more-info",
    "href": "bins_2d.html#more-info",
    "title": "2D histograms",
    "section": "More info",
    "text": "More info\n\nIf you set the point shape to 21, you have control over both color and fill.\n\nBinsScaleOptions\n\n\n\nBINS:\n\n\nThe value for bins will be vary depending on the variable values–there is no correct number. If the number of bins is too low, the density may hide important nuances between the variables. If the number of bins is too high, the noise might drown out the signal.\nBelow we change the bins to 9, 12 and 18 to compare the display:\n\n\n\n\nCode\nggp2_base &lt;- ggplot(data = penguins_2dhist, \n    mapping = aes(x = bill_length_mm, \n                  y = flipper_length_mm))\n\nggp2_2dhist_bins18 &lt;- ggp2_base + \n                    geom_bin2d(bins = 18)\n\nggp2_2dhist_bins12 &lt;- ggp2_base + \n                    geom_bin2d(bins = 12) \n\nggp2_2dhist_bins9 &lt;- ggp2_base + \n                    geom_bin2d(bins = 9)\n\nggp2_2dhist_bins18 + \n     labs_2dhist \n\nggp2_2dhist + \n    labs_2dhist\n\nggp2_2dhist_bins12 + \n     labs_2dhist \n\nggp2_2dhist_bins9 + \n  labs_2dhist\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSCALES:\n\n\nscale_fill_continuous_sequential() comes with a variety of palettes to choose from (run hcl_palettes(type = \"sequential\") to view the full list).\nWe can also reverse the order of the fill color scale with rev (TRUE or FALSE).\n\n\n\n\nCode\nggp2_2dhist_bins12 + \n    scale_fill_continuous_sequential(\n        palette = \"Mako\", \n        rev = TRUE) +\n    labs_2dhist \n\nggp2_2dhist_bins12 + \n    scale_fill_continuous_sequential(\n        palette = \"Mako\", \n        rev = FALSE) +\n    labs_2dhist \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOPTIONS:\n\n\n\nIn the previous example we showed how to reverse the color scale for the palette in scale_fill_continuous_sequential(). Below we reverse the color scale, but also manually set which colors on the scale we want to begin with (i.e., smallest data value) and which color we want to end with (i.e., the largest data value). Possible values range from 0 - 1.\nWe also add a geom_point() layer.\n\n\n\n\nCode\nggp2_2dhist_bins12 +\n  scale_fill_continuous_sequential(\n    palette = \"SunsetDark\",\n    rev = TRUE,\n    begin = 1.0,\n    end = 0.3) +\n  geom_point(\n    fill = \"#D4F0FC\",\n    color = \"#02577A\",\n    shape = 21,\n    size = 1.8,\n    alpha = 0.60) +\n  labs_2dhist"
  },
  {
    "objectID": "hex_bins.html#description",
    "href": "hex_bins.html#description",
    "title": "Hexagon bins",
    "section": "Description",
    "text": "Description\nHexagon bins (or hex-bins) are a very similar to 2-D histograms, but instead of dividing the graph area into a grid, it’s divided into hexagons. The number of points inside each per hexagon determine it’s color."
  },
  {
    "objectID": "hex_bins.html#set-up",
    "href": "hex_bins.html#set-up",
    "title": "Hexagon bins",
    "section": "Set up",
    "text": "Set up"
  },
  {
    "objectID": "hex_bins.html#grammar",
    "href": "hex_bins.html#grammar",
    "title": "Hexagon bins",
    "section": "Grammar",
    "text": "Grammar"
  },
  {
    "objectID": "hex_bins.html#more-info",
    "href": "hex_bins.html#more-info",
    "title": "Hexagon bins",
    "section": "More info",
    "text": "More info\n\nBinsScaleOptions\n\n\n\nBINS:\n\n\nBelow we change the bins to 20 and 15 and save these layers as ggp2_hex_b20 and ggp2_hex_b15.\nDecreasing the number of bins increases the size of the hexagons (and makes them larger).\n\n\n\n\nCode\nggp2_hex_b20 &lt;- ggplot(data = penguins_hex,\n    aes(x = bill_length_mm, y = flipper_length_mm)) +\n    geom_hex(bins = 20)\nggp2_hex_b20 +\n    labs_hex\n\n\nggp2_hex_b15 &lt;- ggplot(data = penguins_hex,\n    aes(x = bill_length_mm, y = flipper_length_mm)) +\n    geom_hex(bins = 15)\nggp2_hex_b15 +\n    labs_hex\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSCALES:\n\n\nWe can adjust the color scale using scale_color_discrete_sequential() and setting aesthetics to \"fill\".\nIf the hexagons overlap, we can use the alpha to make them slightly transparent.\n\n\n\n\nCode\nlabs_hex2 &lt;- labs(\n    title = \"Adult Foraging Penguins\", \n    subtitle = \"Near Palmer Station, Antarctica\", \n    x = \"Bill length (mm)\", \n    y = \"Flipper length (mm)\",\n    fill = \"Sex\")\nggplot(data = penguins_hex, \n    aes(x = bill_length_mm, \n        y = flipper_length_mm)) + \n    geom_hex(aes(fill = sex), \n             bins = 15, \n             alpha = 3/4) + \n    scale_color_discrete_sequential(\n        aesthetics = \"fill\", \n        rev = FALSE,\n        palette = \"Viridis\") +\n    labs_hex2\n\n\n\n\n\n\n\n\n\n\nGet a full list of available color palette’s using hcl_palettes(type = \"sequential\")\n\n\n\n\n\nOPTIONS:\n\n\nbinwidth allows us to manually adjust the size of the hexagons.\nlinewidth is also helpful when using alpha for overlapping values.\n\n\n\n\nCode\nlabs_hex3 &lt;- labs(\n    title = \"Adult Foraging Penguins\", \n    subtitle = \"Near Palmer Station, Antarctica\", \n    x = \"Bill length (mm)\", \n    y = \"Flipper length (mm)\",\n    fill = \"Species\")\n\nggplot(data = penguins_hex, \n    aes(x = bill_length_mm, \n        y = flipper_length_mm, \n        fill = species)) + \n    geom_hex(binwidth = c(1.1, 3),\n        linewidth = 0.5, \n        alpha = 3/4,\n        color = \"#000000\") + \n    scale_color_discrete_sequential(\n        aesthetics = \"fill\", \n        palette = \"Dark Mint\") +\n    labs_hex3\n\n\n\n\n\n\n\n\n\n\n\nBins can be set with bins (a single number) or binwidth (a numeric vector of c(x, y))"
  },
  {
    "objectID": "xtnsns_tbl.html",
    "href": "xtnsns_tbl.html",
    "title": "ggplot2 extensions",
    "section": "",
    "text": "Below are the graphs requiring additional packages/extensions:\n\n\n\n\nGraph\nPackage\nCode\n\n\n\n\nWaffle charts\nggwaffle\nremotes::install_github(\"liamgilbey/ggwaffle\")\nlibrary(ggwaffle)\n\n\nPie charts\nggpubr\nremotes::install_github(\"kassambara/ggpubr\")\nlibrary(ggpubr)\n\n\nMosaic Plots\nggmosaic\nremotes::install_github(\"haleyjeppson/ggmosaic\")\nlibrary(ggmosaic)\n\n\nTreemaps\ntreemapify\nremotes::install_github(\"wilkox/treemapify\")\nlibrary(treemapify)\n\n\nBeeswarm Plots\nggbeeswarm\nremotes::install_github(\"eclarke/ggbeeswarm\")\nlibrary(ggbeeswarm)\n\n\nRidgeline Plots\nggridges\nremotes::install_github(\"wilkelab/ggridges\")\nlibrary(ggridges)\n\n\nRaincloud plots\nraincloudplots & ggdist\nremotes::install_github('jorvlan/raincloudplots')\nremotes::install_github('mjskay/ggdist')\nlibrary(raincloudplots)\nlibrary(ggdist)\n\n\nAlluvial charts\nggalluvial\nremotes::install_github(\"corybrunson/ggalluvial\")\nlibrary(ggalluvial)\n\n\nParallel Sets\nggforce\nremotes::install_github(\"thomasp85/ggforce\")\nlibrary(ggforce)\n\n\nBump charts\nggbump\nremotes::install_github(\"davidsjoberg/ggbump\")\nlibrary(ggbump)\n\n\nStream Plots\nggstream\nremotes::install_github(\"davidsjoberg/ggstream\")\nlibrary(ggstream)"
  }
]